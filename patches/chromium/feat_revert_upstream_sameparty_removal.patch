From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Keeley Hammond <khammond@slack-corp.com>
Date: Tue, 27 Feb 2024 22:34:57 -0800
Subject: feat: revert upstream SameParty removal

This patch removes the SameParty removal by Chrome,
to make future Electron versions compatible with
SameParty.

Revert "[RWS] Rewrite FPSParser to return net::GlobalFirstPartySets" | This reverts commit 3d65d32b9dbfa822c8883a11ea7b3f1cb3aacd00.
Revert "[RWS] Remove enum from parser's public API" | This reverts commit e0404fe08b2823ca2546bd2665e986595ebf43b2.
5146347: [RWS] Introduce a wrapper type to hold RWSOverrides policy data | https://chromium-review.googlesource.com/c/chromium/src/+/5146347
Revert "[RWS] Introduce SetsMutation type to uphold invariants" | This reverts commit 7d1bad4a311e8532a56e65eb68557f51e7c1c35e.
Revert "[RWS] Store local-set-aliases separately; detect shadowing properly" | This reverts commit d4176432c1cf25b3eb6de159ec3aa0e9a1c1eec0.
Revert "[RWS] Rewrite LocalSetDeclaration ctor to accept aliases separately" | This reverts commit 60fa94a5216486f0a64550661db375c909a710d4.
Revert "[RWS] Move switch-parsing code to FPSParser; move LocalSetDecl to net/" | This reverts commit bd490b71bd1ce505f0ec9f1749ae4d1079e008b7.
Revert "[RWS] Remove CanonicalCookie::IsSameParty method" | This reverts commit 009417ac633095bcd3d0b8eca6b00b5189c1ca1f.
Revert "[RWS] Remove unused same_party ctor parameter" | This reverts commit 23703ad3a827df582cff2b9844c8179f15281a5d.
Revert "[RWS] Remove SameParty state from CanonicalCookie and ParsedCookie" | This reverts commit 2f9574c931607cbb64d17b66a6e28f7408ef7457.

diff --git a/chrome/browser/extensions/api/cookies/cookies_api.cc b/chrome/browser/extensions/api/cookies/cookies_api.cc
index 37704856cf800a479cf20774047f6694e2374405..4eda7e676a6ac67b7673b5306e531426bb335d9c 100644
--- a/chrome/browser/extensions/api/cookies/cookies_api.cc
+++ b/chrome/browser/extensions/api/cookies/cookies_api.cc
@@ -487,6 +487,7 @@ ExtensionFunction::ResponseAction CookiesSetFunction::Run() {
       break;
   }
 
+  // TODO(crbug.com/1144181): Add support for SameParty attribute.
   std::unique_ptr<net::CanonicalCookie> cc(
       net::CanonicalCookie::CreateSanitizedCookie(
           url_,                                                  //
@@ -501,6 +502,7 @@ ExtensionFunction::ResponseAction CookiesSetFunction::Run() {
           parsed_args_->details.http_only.value_or(false),       //
           same_site,                                             //
           net::COOKIE_PRIORITY_DEFAULT,                          //
+          /*same_party=*/false,                                  //
           partition_key));
   if (!cc) {
     // Return error through callbacks so that the proper error message
diff --git a/components/signin/core/browser/consistency_cookie_manager.cc b/components/signin/core/browser/consistency_cookie_manager.cc
index f4308054e070b4468ef2f22da88a25132ce92ca9..421f9ab6edf717128b255019bb3da7831df879a4 100644
--- a/components/signin/core/browser/consistency_cookie_manager.cc
+++ b/components/signin/core/browser/consistency_cookie_manager.cc
@@ -115,7 +115,7 @@ ConsistencyCookieManager::CreateConsistencyCookie(const std::string& value) {
       /*path=*/"/", /*creation=*/now, /*expiration=*/expiry,
       /*last_access=*/now, /*secure=*/true, /*httponly=*/false,
       net::CookieSameSite::STRICT_MODE, net::COOKIE_PRIORITY_DEFAULT,
-      /*partition_key=*/absl::nullopt);
+      /*same_party=*/false, /*partition_key=*/absl::nullopt);
 }
 
 // static
diff --git a/components/signin/internal/identity_manager/gaia_cookie_manager_service.cc b/components/signin/internal/identity_manager/gaia_cookie_manager_service.cc
index 2e8e994bd86df365d15255d7214becc5d5db798c..db330455e9e22ca27e9a2602ba5bdc206dba6b7b 100644
--- a/components/signin/internal/identity_manager/gaia_cookie_manager_service.cc
+++ b/components/signin/internal/identity_manager/gaia_cookie_manager_service.cc
@@ -569,7 +569,7 @@ void GaiaCookieManagerService::ForceOnCookieChangeProcessing() {
           "." + google_url.host(), "/", base::Time(), base::Time(),
           base::Time(), true /* secure */, false /* httponly */,
           net::CookieSameSite::NO_RESTRICTION, net::COOKIE_PRIORITY_DEFAULT,
-          absl::nullopt /* cookie_partition_key */);
+          false /* same_party */, absl::nullopt /* cookie_partition_key */);
   OnCookieChange(
       net::CookieChangeInfo(*cookie, net::CookieAccessResult(),
                             net::CookieChangeCause::UNKNOWN_DELETION));
diff --git a/components/signin/ios/browser/account_consistency_service.mm b/components/signin/ios/browser/account_consistency_service.mm
index 592a2dc9a34ac8edb9de34f9429c8a20eca9cfe0..2798cc7eec57d2c6b2d843343c1b575d3abbe283 100644
--- a/components/signin/ios/browser/account_consistency_service.mm
+++ b/components/signin/ios/browser/account_consistency_service.mm
@@ -490,7 +490,7 @@ void ShouldAllowResponse(
           /*last_access_time=*/base::Time(),
           /*secure=*/true,
           /*httponly=*/false, net::CookieSameSite::LAX_MODE,
-          net::COOKIE_PRIORITY_DEFAULT,
+          net::COOKIE_PRIORITY_DEFAULT, /*same_party=*/false,
           /*partition_key=*/absl::nullopt);
   net::CookieOptions options;
   options.set_include_httponly();
diff --git a/content/app/content_main_runner_impl.cc b/content/app/content_main_runner_impl.cc
index 48f1cdd0a7763242b81c7a54cad72700c8a42af1..f971be672f7e975d9ca173c579345e7dc3382661 100644
--- a/content/app/content_main_runner_impl.cc
+++ b/content/app/content_main_runner_impl.cc
@@ -61,6 +61,7 @@
 #include "content/browser/browser_process_io_thread.h"
 #include "content/browser/browser_thread_impl.h"
 #include "content/browser/first_party_sets/first_party_sets_handler_impl.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/browser/gpu/gpu_main_thread_factory.h"
 #include "content/browser/renderer_host/render_process_host_impl.h"
 #include "content/browser/scheduler/browser_task_executor.h"
@@ -104,7 +105,6 @@
 #include "mojo/public/cpp/system/dynamic_library_support.h"
 #include "mojo/public/cpp/system/invitation.h"
 #include "mojo/public/cpp/system/message_pipe.h"
-#include "net/first_party_sets/local_set_declaration.h"
 #include "ppapi/buildflags/buildflags.h"
 #include "sandbox/policy/sandbox.h"
 #include "sandbox/policy/sandbox_type.h"
@@ -1259,7 +1259,7 @@ int ContentMainRunnerImpl::RunBrowser(MainFunctionParams main_params,
       // Minimal browser mode doesn't initialize First-Party Sets the "usual"
       // way, so we do it manually.
       content::FirstPartySetsHandlerImpl::GetInstance()->Init(
-          base::FilePath(), net::LocalSetDeclaration());
+          base::FilePath(), LocalSetDeclaration());
     }
 
     discardable_shared_memory_manager_ =
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 143c98e3294fb07b08c1d8e97013034f8453e074..60afe83542bae8e45a66946044db2e573f934e4b 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -1030,6 +1030,8 @@ source_set("browser") {
     "first_party_sets/first_party_sets_overrides_policy.h",
     "first_party_sets/first_party_sets_site_data_remover.cc",
     "first_party_sets/first_party_sets_site_data_remover.h",
+    "first_party_sets/local_set_declaration.cc",
+    "first_party_sets/local_set_declaration.h",
     "font_access/font_access_manager.cc",
     "font_access/font_access_manager.h",
     "font_access/font_enumeration_cache.cc",
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index 8c144725c6e54172d01b90e1d1196679a53f4b78..6f3661179225e322b2343e6ff4600073966a682d 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -70,8 +70,8 @@
 #include "content/browser/compositor/viz_process_transport_factory.h"
 #include "content/browser/download/save_file_manager.h"
 #include "content/browser/field_trial_synchronizer.h"
-#include "content/browser/first_party_sets/first_party_set_parser.h"
 #include "content/browser/first_party_sets/first_party_sets_handler_impl.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/browser/gpu/browser_gpu_channel_host_factory.h"
 #include "content/browser/gpu/browser_gpu_client_delegate.h"
 #include "content/browser/gpu/compositor_util.h"
@@ -1009,8 +1009,7 @@ int BrowserMainLoop::PreMainMessageLoopRun() {
   if (result_code_ == RESULT_CODE_NORMAL_EXIT) {
     FirstPartySetsHandlerImpl::GetInstance()->Init(
         GetContentClient()->browser()->GetFirstPartySetsDirectory(),
-        FirstPartySetParser::ParseFromCommandLine(
-            GetRelatedWebsiteSetSwitch()));
+        LocalSetDeclaration(GetRelatedWebsiteSetSwitch()));
   }
 
   variations::MaybeScheduleFakeCrash();
diff --git a/content/browser/devtools/protocol/network_handler.cc b/content/browser/devtools/protocol/network_handler.cc
index 2bbc46fd4748246b7fa3e6a8cfe38b43684bf8d7..452b5ee7f29d8778326880f7a92bac996e97245a 100644
--- a/content/browser/devtools/protocol/network_handler.cc
+++ b/content/browser/devtools/protocol/network_handler.cc
@@ -186,7 +186,7 @@ std::unique_ptr<Network::Cookie> BuildCookie(
           .SetSecure(cookie.IsSecure())
           .SetSession(!cookie.IsPersistent())
           .SetPriority(BuildCookiePriority(cookie.Priority()))
-          .SetSameParty(false)
+          .SetSameParty(cookie.IsSameParty())
           .SetSourceScheme(BuildCookieSourceScheme(cookie.SourceScheme()))
           .SetSourcePort(cookie.SourcePort())
           .Build();
@@ -349,6 +349,7 @@ MakeCookieFromProtocolValues(const std::string& name,
                              const std::string& same_site,
                              double expires,
                              const std::string& priority,
+                             bool same_party,
                              const Maybe<std::string>& source_scheme,
                              const Maybe<int>& source_port,
                              const Maybe<std::string>& partition_key) {
@@ -423,7 +424,7 @@ MakeCookieFromProtocolValues(const std::string& name,
   std::unique_ptr<net::CanonicalCookie> cookie =
       net::CanonicalCookie::CreateSanitizedCookie(
           url, name, value, normalized_domain, path, base::Time(),
-          expiration_date, base::Time(), secure, http_only, css, cp,
+          expiration_date, base::Time(), secure, http_only, css, cp, same_party,
           deserialized_partition_key);
 
   if (!cookie)
@@ -1567,8 +1568,8 @@ void NetworkHandler::SetCookie(const std::string& name,
   auto cookie_or_error = MakeCookieFromProtocolValues(
       name, value, url.value_or(""), domain.value_or(""), path.value_or(""),
       secure.value_or(false), http_only.value_or(false), same_site.value_or(""),
-      expires.value_or(-1), priority.value_or(""), source_scheme, source_port,
-      partition_key);
+      expires.value_or(-1), priority.value_or(""), same_party.value_or(false),
+      source_scheme, source_port, partition_key);
 
   if (absl::holds_alternative<Response>(cookie_or_error)) {
     callback->sendFailure(absl::get<Response>(std::move(cookie_or_error)));
@@ -1616,8 +1617,8 @@ void NetworkHandler::SetCookies(
         cookie->GetName(), cookie->GetValue(), cookie->GetUrl(""),
         cookie->GetDomain(""), cookie->GetPath(""), cookie->GetSecure(false),
         cookie->GetHttpOnly(false), cookie->GetSameSite(""),
-        cookie->GetExpires(-1), cookie->GetPriority(""), source_scheme,
-        source_port, partition_key);
+        cookie->GetExpires(-1), cookie->GetPriority(""),
+        cookie->GetSameParty(false), source_scheme, source_port, partition_key);
     if (absl::holds_alternative<Response>(net_cookie_or_error)) {
       // TODO: Investiage whether we can report the error as a protocol error
       // (this might be a breaking CDP change).
diff --git a/content/browser/first_party_sets/first_party_set_parser.cc b/content/browser/first_party_sets/first_party_set_parser.cc
index 5465b7801280a76017e4cb0552d01a4d179b7dc7..af422c4a8c7221048c5f061344ffbfc71b8f548d 100644
--- a/content/browser/first_party_sets/first_party_set_parser.cc
+++ b/content/browser/first_party_sets/first_party_set_parser.cc
@@ -29,9 +29,7 @@
 #include "net/base/registry_controlled_domains/registry_controlled_domain.h"
 #include "net/base/schemeful_site.h"
 #include "net/first_party_sets/first_party_set_entry.h"
-#include "net/first_party_sets/global_first_party_sets.h"
-#include "net/first_party_sets/local_set_declaration.h"
-#include "net/first_party_sets/sets_mutation.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 #include "url/gurl.h"
 #include "url/origin.h"
 
@@ -43,10 +41,9 @@ using ParseErrorType = FirstPartySetsHandler::ParseErrorType;
 using ParseWarningType = FirstPartySetsHandler::ParseWarningType;
 using ParseError = FirstPartySetsHandler::ParseError;
 using ParseWarning = FirstPartySetsHandler::ParseWarning;
-using SetsMap = base::flat_map<net::SchemefulSite, net::FirstPartySetEntry>;
-using Aliases = base::flat_map<net::SchemefulSite, net::SchemefulSite>;
-using SetsAndAliases = std::pair<SetsMap, Aliases>;
-using SingleSet = base::flat_map<net::SchemefulSite, net::FirstPartySetEntry>;
+using Aliases = FirstPartySetParser::Aliases;
+using SetsAndAliases = FirstPartySetParser::SetsAndAliases;
+using SetsMap = FirstPartySetParser::SetsMap;
 
 constexpr char kFirstPartySetPrimaryField[] = "primary";
 constexpr char kFirstPartySetAssociatedSitesField[] = "associatedSites";
@@ -57,13 +54,11 @@ constexpr char kFirstPartySetPolicyAdditionsField[] = "additions";
 
 constexpr int kFirstPartySetsMaxAssociatedSites = 5;
 
-enum class PolicySetType { kReplacement, kAddition };
-
-const char* SetTypeToString(PolicySetType set_type) {
+const char* SetTypeToString(FirstPartySetParser::PolicySetType set_type) {
   switch (set_type) {
-    case PolicySetType::kReplacement:
+    case FirstPartySetParser::PolicySetType::kReplacement:
       return kFirstPartySetPolicyReplacementsField;
-    case PolicySetType::kAddition:
+    case FirstPartySetParser::PolicySetType::kAddition:
       return kFirstPartySetPolicyAdditionsField;
   }
 }
@@ -154,11 +149,6 @@ std::optional<std::string> RemoveTldFromSite(const net::SchemefulSite& site) {
   return serialized.substr(0, serialized.size() - tld_length);
 }
 
-struct ParsedPolicySetLists {
-  std::vector<SingleSet> replacements;
-  std::vector<SingleSet> additions;
-};
-
 class ParseContext {
  public:
   ParseContext(bool emit_errors, bool exempt_from_limits)
@@ -273,18 +263,18 @@ class ParseContext {
                                          {kFirstPartySetAssociatedSitesField}));
     }
 
-    return std::make_pair(SingleSet(set_entries), aliases);
+    return std::make_pair(FirstPartySetParser::SingleSet(set_entries), aliases);
   }
 
   // Returns the parsed sets if successful; otherwise returns the first error.
-  base::expected<std::vector<SingleSet>, ParseError> GetPolicySetsFromList(
-      const base::Value::List* policy_sets,
-      PolicySetType set_type) {
+  base::expected<std::vector<FirstPartySetParser::SingleSet>, ParseError>
+  GetPolicySetsFromList(const base::Value::List* policy_sets,
+                        FirstPartySetParser::PolicySetType set_type) {
     if (!policy_sets) {
       return {};
     }
 
-    std::vector<SingleSet> parsed_sets;
+    std::vector<FirstPartySetParser::SingleSet> parsed_sets;
     size_t previous_size = warnings_.size();
     for (int i = 0; i < static_cast<int>(policy_sets->size()); i++) {
       base::expected<SetsAndAliases, ParseError> parsed =
@@ -339,20 +329,13 @@ class ParseContext {
   // Removes invalid site entries and aliases, and fixes up any lingering
   // singletons. Modifies the data in-place.
   void PostProcessSets(std::vector<SetsMap::value_type>& sets,
-                       std::vector<Aliases::value_type>& aliases) {
+                       std::vector<Aliases::value_type>& aliases) const {
     if (invalid_keys_.empty()) {
       return;
     }
 
     base::flat_set<net::SchemefulSite> possible_singletons;
 
-    // Erase invalid members/primaries, and collect primary sites that might
-    // become singletons.
-    base::EraseIf(
-        sets,
-        [&](const std::pair<net::SchemefulSite, net::FirstPartySetEntry>& pair)
-            -> bool { return IsInvalidEntry(pair, &possible_singletons); });
-
     // Erase invalid aliases, and collect canonical sites that are primaries and
     // might become singletons.
     base::EraseIf(
@@ -362,6 +345,13 @@ class ParseContext {
           return IsInvalidAlias(pair, possible_singletons, sets);
         });
 
+    // Erase invalid members/primaries, and collect primary sites that might
+    // become singletons.
+    base::EraseIf(
+        sets,
+        [&](const std::pair<net::SchemefulSite, net::FirstPartySetEntry>& pair)
+            -> bool { return IsInvalidEntry(pair, &possible_singletons); });
+
     if (possible_singletons.empty()) {
       return;
     }
@@ -399,13 +389,13 @@ class ParseContext {
   // Removes invalid site entries and fixes up any lingering singletons.
   // Modifies the lists in-place.
   void PostProcessSetLists(
-      base::expected<ParsedPolicySetLists, FirstPartySetsHandler::ParseError>&
-          lists_or_error) {
+      base::expected<FirstPartySetParser::ParsedPolicySetLists,
+                     FirstPartySetsHandler::ParseError>& lists_or_error) const {
     if (!lists_or_error.has_value() || invalid_keys_.empty()) {
       return;
     }
 
-    ParsedPolicySetLists& lists = lists_or_error.value();
+    FirstPartySetParser::ParsedPolicySetLists& lists = lists_or_error.value();
 
     // Erase invalid members/primaries.
     const auto is_invalid_entry =
@@ -422,7 +412,7 @@ class ParseContext {
 
     // Since we just removed some keys, we have to double-check that there are
     // no singleton sets.
-    const auto is_singleton = [](const SingleSet& set) {
+    const auto is_singleton = [](const FirstPartySetParser::SingleSet& set) {
       return set.size() <= 1;
     };
     base::EraseIf(lists.additions, is_singleton);
@@ -604,27 +594,20 @@ class ParseContext {
   // set.
   bool IsInvalidEntry(
       const std::pair<net::SchemefulSite, net::FirstPartySetEntry> pair,
-      base::flat_set<net::SchemefulSite>* possible_singletons) {
+      base::flat_set<net::SchemefulSite>* possible_singletons) const {
     const net::SchemefulSite& key = pair.first;
     const net::FirstPartySetEntry& entry = pair.second;
     return base::ranges::any_of(
         invalid_keys_, [&](const net::SchemefulSite& invalid_key) -> bool {
-          if (invalid_key == entry.primary()) {
-            // The primary is invalid, so we have to kill the whole set. So this
-            // non-primary site must also be considered invalid in the future.
-            invalid_keys_.insert(pair.first);
-            return true;
-          }
-          if (invalid_key == key) {
+          const bool key_matches = invalid_key == key;
+          const bool primary_matches = invalid_key == entry.primary();
+          if (key_matches && !primary_matches && possible_singletons) {
             // This is a member whose primary might end up being a
             // singleton, since it's losing at least one member (and it
             // itself isn't invalid).
-            if (possible_singletons) {
-              possible_singletons->insert(entry.primary());
-            }
-            return true;
+            possible_singletons->insert(entry.primary());
           }
-          return false;
+          return key_matches || primary_matches;
         });
   }
 
@@ -673,9 +656,43 @@ class ParseContext {
   mutable base::flat_set<SetsMap::key_type> invalid_keys_;
 };
 
-SetsAndAliases ParseSetsFromStreamInternal(std::istream& input,
-                                           bool emit_errors,
-                                           bool emit_metrics) {
+}  // namespace
+
+FirstPartySetParser::ParsedPolicySetLists::ParsedPolicySetLists(
+    std::vector<FirstPartySetParser::SingleSet> replacement_list,
+    std::vector<FirstPartySetParser::SingleSet> addition_list)
+    : replacements(std::move(replacement_list)),
+      additions(std::move(addition_list)) {}
+
+FirstPartySetParser::ParsedPolicySetLists::ParsedPolicySetLists() = default;
+FirstPartySetParser::ParsedPolicySetLists::ParsedPolicySetLists(
+    FirstPartySetParser::ParsedPolicySetLists&&) = default;
+FirstPartySetParser::ParsedPolicySetLists::ParsedPolicySetLists(
+    const FirstPartySetParser::ParsedPolicySetLists&) = default;
+FirstPartySetParser::ParsedPolicySetLists::~ParsedPolicySetLists() = default;
+
+bool FirstPartySetParser::ParsedPolicySetLists::operator==(
+    const FirstPartySetParser::ParsedPolicySetLists& other) const {
+  return std::tie(replacements, additions) ==
+         std::tie(other.replacements, other.additions);
+}
+
+absl::optional<net::SchemefulSite>
+FirstPartySetParser::CanonicalizeRegisteredDomain(
+    const base::StringPiece origin_string,
+    bool emit_errors) {
+  ValidateSiteResult result =
+      ParseContext(emit_errors, /*exempt_from_limits=*/false)
+          .Canonicalize(origin_string);
+  if (result.has_error()) {
+    return absl::nullopt;
+  }
+  return result.site();
+}
+
+SetsAndAliases FirstPartySetParser::ParseSetsFromStream(std::istream& input,
+                                                        bool emit_errors,
+                                                        bool emit_metrics) {
   std::vector<SetsMap::value_type> sets;
   std::vector<Aliases::value_type> aliases;
   ParseContext context(emit_errors, /*exempt_from_limits=*/false);
@@ -728,35 +745,7 @@ SetsAndAliases ParseSetsFromStreamInternal(std::istream& input,
     base::UmaHistogramCounts1000(
         "Cookie.FirstPartySets.ComponentSetsNonfatalErrors", nonfatal_errors);
   }
-
-  return std::make_pair(std::move(sets), std::move(aliases));
-}
-
-}  // namespace
-
-std::optional<net::SchemefulSite>
-FirstPartySetParser::CanonicalizeRegisteredDomain(
-    const base::StringPiece origin_string,
-    bool emit_errors) {
-  ValidateSiteResult result =
-      ParseContext(emit_errors, /*exempt_from_limits=*/false)
-          .Canonicalize(origin_string);
-  if (result.has_error()) {
-    return std::nullopt;
-  }
-  return result.site();
-}
-
-net::GlobalFirstPartySets FirstPartySetParser::ParseSetsFromStream(
-    std::istream& input,
-    base::Version version,
-    bool emit_errors,
-    bool emit_metrics) {
-  SetsAndAliases sets_and_aliases =
-      ParseSetsFromStreamInternal(input, emit_errors, emit_metrics);
-  return net::GlobalFirstPartySets(std::move(version),
-                                   std::move(sets_and_aliases.first),
-                                   std::move(sets_and_aliases.second));
+  return std::make_pair(sets, aliases);
 }
 
 FirstPartySetParser::PolicyParseResult
@@ -778,43 +767,27 @@ FirstPartySetParser::ParseSetsFromEnterprisePolicy(
 
   context.PostProcessSetLists(set_lists);
 
-  return FirstPartySetParser::PolicyParseResult(
-      std::move(set_lists).transform([](ParsedPolicySetLists lists) {
-        return FirstPartySetsOverridesPolicy(net::SetsMutation(
-            std::move(lists.replacements), std::move(lists.additions)));
-      }),
-      context.warnings());
+  return FirstPartySetParser::PolicyParseResult(std::move(set_lists),
+                                                context.warnings());
 }
 
-// static
-net::LocalSetDeclaration FirstPartySetParser::ParseFromCommandLine(
-    const std::string& switch_value) {
-  std::istringstream stream(switch_value);
-
-  SetsAndAliases parsed =
-      ParseSetsFromStreamInternal(stream, /*emit_errors=*/true,
-                                  /*emit_metrics*/ false);
-
-  SetsMap entries = std::move(parsed.first);
-  Aliases aliases = std::move(parsed.second);
-
-  if (entries.empty()) {
-    return net::LocalSetDeclaration();
+std::ostream& operator<<(
+    std::ostream& os,
+    const FirstPartySetParser::ParsedPolicySetLists& lists) {
+  os << "additions: {";
+  for (const auto& set : lists.additions) {
+    for (const auto& pair : set) {
+      os << pair.first << " -> " << pair.second << ", ";
+    }
   }
-
-  const net::SchemefulSite& primary = entries.begin()->second.primary();
-
-  if (base::ranges::any_of(entries,
-                           [&primary](const SetsMap::value_type& pair) {
-                             return pair.second.primary() != primary;
-                           })) {
-    // More than one set was provided. That is (currently) unsupported.
-    LOG(ERROR) << "Ignoring use-related-website-set switch due to multiple set "
-                  "declarations.";
-    return net::LocalSetDeclaration();
+  os << "}, replacements: {";
+  for (const auto& set : lists.replacements) {
+    for (const auto& pair : set) {
+      os << pair.first << " -> " << pair.second << ", ";
+    }
   }
-
-  return net::LocalSetDeclaration(std::move(entries), std::move(aliases));
+  os << "}";
+  return os;
 }
 
 }  // namespace content
diff --git a/content/browser/first_party_sets/first_party_set_parser.h b/content/browser/first_party_sets/first_party_set_parser.h
index 47c07a209a9afafc696f3aabbef97422727f5195..d91cd5d119b1da6247d04bb28dd8c529c65deb85 100644
--- a/content/browser/first_party_sets/first_party_set_parser.h
+++ b/content/browser/first_party_sets/first_party_set_parser.h
@@ -18,18 +18,39 @@
 #include "content/public/browser/first_party_sets_handler.h"
 #include "net/base/schemeful_site.h"
 #include "net/first_party_sets/first_party_set_entry.h"
-#include "net/first_party_sets/global_first_party_sets.h"
-#include "net/first_party_sets/local_set_declaration.h"
-#include "net/first_party_sets/sets_mutation.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace content {
 
 class CONTENT_EXPORT FirstPartySetParser {
  public:
-  using PolicyParseResult =
-      std::pair<base::expected<FirstPartySetsOverridesPolicy,
-                               FirstPartySetsHandler::ParseError>,
-                std::vector<FirstPartySetsHandler::ParseWarning>>;
+  using SetsMap = base::flat_map<net::SchemefulSite, net::FirstPartySetEntry>;
+  // Keys are alias sites, values are their canonical representatives.
+  using Aliases = base::flat_map<net::SchemefulSite, net::SchemefulSite>;
+  using SingleSet = SetsMap;
+  using SetsAndAliases = std::pair<SetsMap, Aliases>;
+  enum class PolicySetType { kReplacement, kAddition };
+
+  struct CONTENT_EXPORT ParsedPolicySetLists {
+    ParsedPolicySetLists(std::vector<SingleSet> replacement_list,
+                         std::vector<SingleSet> addition_list);
+
+    ParsedPolicySetLists();
+    ParsedPolicySetLists(ParsedPolicySetLists&&);
+    ParsedPolicySetLists& operator=(ParsedPolicySetLists&&) = default;
+    ParsedPolicySetLists(const ParsedPolicySetLists&);
+    ParsedPolicySetLists& operator=(const ParsedPolicySetLists&) = default;
+    ~ParsedPolicySetLists();
+
+    bool operator==(const ParsedPolicySetLists& other) const;
+
+    std::vector<SingleSet> replacements;
+    std::vector<SingleSet> additions;
+  };
+
+  using PolicyParseResult = std::pair<
+      base::expected<ParsedPolicySetLists, FirstPartySetsHandler::ParseError>,
+      std::vector<FirstPartySetsHandler::ParseWarning>>;
 
   FirstPartySetParser() = delete;
   ~FirstPartySetParser() = delete;
@@ -43,12 +64,11 @@ class CONTENT_EXPORT FirstPartySetParser {
   // not check versions or assertions, since it is intended only for sets
   // received by Component Updater.
   //
-  // Returns an empty GlobalFirstPartySets instance if parsing or validation of
-  // any set failed.
-  static net::GlobalFirstPartySets ParseSetsFromStream(std::istream& input,
-                                                       base::Version version,
-                                                       bool emit_errors,
-                                                       bool emit_metrics);
+  // Returns an empty map if parsing or validation of any set failed. Must not
+  // be called before field trial state has been initialized.
+  static SetsAndAliases ParseSetsFromStream(std::istream& input,
+                                            bool emit_errors,
+                                            bool emit_metrics);
 
   // Canonicalizes the passed in origin to a registered domain. In particular,
   // this ensures that the origin is non-opaque, is HTTPS, and has a registered
@@ -64,11 +84,12 @@ class CONTENT_EXPORT FirstPartySetParser {
   // returns an error.
   [[nodiscard]] static PolicyParseResult ParseSetsFromEnterprisePolicy(
       const base::Value::Dict& policy);
-
-  [[nodiscard]] static net::LocalSetDeclaration ParseFromCommandLine(
-      const std::string& switch_value);
 };
 
+CONTENT_EXPORT std::ostream& operator<<(
+    std::ostream& os,
+    const FirstPartySetParser::ParsedPolicySetLists& lists);
+
 }  // namespace content
 
 #endif  // CONTENT_BROWSER_FIRST_PARTY_SETS_FIRST_PARTY_SET_PARSER_H_
diff --git a/content/browser/first_party_sets/first_party_sets_handler_impl.h b/content/browser/first_party_sets/first_party_sets_handler_impl.h
index b183d8841eda1fa05ecaf01f63d88fb4e6e7689d..7ab1e87244746b03e420290c254cd1ab8aa9295c 100644
--- a/content/browser/first_party_sets/first_party_sets_handler_impl.h
+++ b/content/browser/first_party_sets/first_party_sets_handler_impl.h
@@ -9,10 +9,12 @@
 
 #include "base/files/file_path.h"
 #include "base/functional/callback.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/first_party_sets_handler.h"
 #include "net/first_party_sets/global_first_party_sets.h"
 #include "net/first_party_sets/local_set_declaration.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace content {
 
@@ -35,7 +37,7 @@ class CONTENT_EXPORT FirstPartySetsHandlerImpl : public FirstPartySetsHandler {
   //
   // Only the first call has any effect.
   void virtual Init(const base::FilePath& user_data_dir,
-                    const net::LocalSetDeclaration& local_set) = 0;
+                    const LocalSetDeclaration& local_set) = 0;
 
   // Returns the fully-parsed and validated global First-Party Sets data.
   // Returns the data synchronously via an std::optional if it's already
diff --git a/content/browser/first_party_sets/first_party_sets_handler_impl_instance.cc b/content/browser/first_party_sets/first_party_sets_handler_impl_instance.cc
index 267e0786e139a7a1fc142b6fd1a92e3a5e8c716a..a44fb947444d86c42a016b8141d56d2def67fcf0 100644
--- a/content/browser/first_party_sets/first_party_sets_handler_impl_instance.cc
+++ b/content/browser/first_party_sets/first_party_sets_handler_impl_instance.cc
@@ -13,7 +13,6 @@
 #include "base/functional/bind.h"
 #include "base/logging.h"
 #include "base/metrics/histogram_functions.h"
-#include "base/sequence_checker.h"
 #include "base/task/task_traits.h"
 #include "base/task/thread_pool.h"
 #include "base/types/expected.h"
@@ -24,6 +23,7 @@
 #include "content/browser/first_party_sets/first_party_sets_loader.h"
 #include "content/browser/first_party_sets/first_party_sets_overrides_policy.h"
 #include "content/browser/first_party_sets/first_party_sets_site_data_remover.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/content_browser_client.h"
 #include "content/public/browser/first_party_sets_handler.h"
@@ -32,8 +32,7 @@
 #include "net/first_party_sets/first_party_set_metadata.h"
 #include "net/first_party_sets/first_party_sets_context_config.h"
 #include "net/first_party_sets/global_first_party_sets.h"
-#include "net/first_party_sets/local_set_declaration.h"
-#include "net/first_party_sets/sets_mutation.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace net {
 class SchemefulSite;
@@ -192,7 +191,7 @@ FirstPartySetsHandlerImplInstance::GetSets(
 
 void FirstPartySetsHandlerImplInstance::Init(
     const base::FilePath& user_data_dir,
-    const net::LocalSetDeclaration& local_set) {
+    const LocalSetDeclaration& local_set) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   if (initialized_) {
     return;
@@ -529,12 +528,12 @@ FirstPartySetsHandlerImplInstance::GetContextConfigForPolicyInternal(
   auto [parsed, warnings] =
       FirstPartySetParser::ParseSetsFromEnterprisePolicy(policy);
 
-  if (!parsed.has_value()) {
-    return global_sets_->ComputeConfig(net::SetsMutation());
-  }
-
-  FirstPartySetsOverridesPolicy& policy_result = parsed.value();
-  return global_sets_->ComputeConfig(std::move(policy_result.mutation()));
+  return parsed.has_value()
+             ? global_sets_.value().ComputeConfig(
+                   /*replacement_sets=*/parsed.value().replacements,
+                   /*addition_sets=*/
+                   parsed.value().additions)
+             : net::FirstPartySetsContextConfig();
 }
 
 bool FirstPartySetsHandlerImplInstance::ForEachEffectiveSetEntry(
diff --git a/content/browser/first_party_sets/first_party_sets_handler_impl_instance.h b/content/browser/first_party_sets/first_party_sets_handler_impl_instance.h
index 974da5d2b26053e5624a5a9aa6cee183692b7863..f5b96707c51af8a8ac9d190cf8b0883c7dc213ca 100644
--- a/content/browser/first_party_sets/first_party_sets_handler_impl_instance.h
+++ b/content/browser/first_party_sets/first_party_sets_handler_impl_instance.h
@@ -23,11 +23,13 @@
 #include "content/browser/first_party_sets/first_party_sets_handler_database_helper.h"
 #include "content/browser/first_party_sets/first_party_sets_handler_impl.h"
 #include "content/browser/first_party_sets/first_party_sets_loader.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/common/content_export.h"
 #include "net/first_party_sets/first_party_sets_cache_filter.h"
 #include "net/first_party_sets/first_party_sets_context_config.h"
 #include "net/first_party_sets/global_first_party_sets.h"
 #include "net/first_party_sets/local_set_declaration.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace net {
 class FirstPartySetEntry;
@@ -62,8 +64,8 @@ class CONTENT_EXPORT FirstPartySetsHandlerImplInstance
 
   // FirstPartySetsHandlerImpl:
   void Init(const base::FilePath& user_data_dir,
-            const net::LocalSetDeclaration& local_set) override;
-  [[nodiscard]] std::optional<net::GlobalFirstPartySets> GetSets(
+            const LocalSetDeclaration& local_set) override;
+  [[nodiscard]] absl::optional<net::GlobalFirstPartySets> GetSets(
       base::OnceCallback<void(net::GlobalFirstPartySets)> callback) override;
 
   // FirstPartySetsHandler:
diff --git a/content/browser/first_party_sets/first_party_sets_loader.cc b/content/browser/first_party_sets/first_party_sets_loader.cc
index 21371a4962adf787595b6acba0d4656db563ae52..340f486495e043849754e6429b1065c50b498fce 100644
--- a/content/browser/first_party_sets/first_party_sets_loader.cc
+++ b/content/browser/first_party_sets/first_party_sets_loader.cc
@@ -5,8 +5,11 @@
 #include "content/browser/first_party_sets/first_party_sets_loader.h"
 
 #include <optional>
+#include <iterator>
+#include <set>
 #include <sstream>
 #include <utility>
+#include <vector>
 
 #include "base/containers/flat_map.h"
 #include "base/files/file_util.h"
@@ -15,8 +18,10 @@
 #include "base/task/thread_pool.h"
 #include "base/version.h"
 #include "content/browser/first_party_sets/first_party_set_parser.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "net/first_party_sets/global_first_party_sets.h"
 #include "net/first_party_sets/local_set_declaration.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace content {
 
@@ -39,7 +44,7 @@ FirstPartySetsLoader::~FirstPartySetsLoader() {
 }
 
 void FirstPartySetsLoader::SetManuallySpecifiedSet(
-    const net::LocalSetDeclaration& local_set) {
+    const LocalSetDeclaration& local_set) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   if (manually_specified_set_.has_value()) {
     return;
@@ -96,9 +101,12 @@ void FirstPartySetsLoader::OnReadSetsFile(base::Version version,
   DCHECK_EQ(component_sets_parse_progress_, Progress::kStarted);
 
   std::istringstream stream(raw_sets);
-  sets_ = FirstPartySetParser::ParseSetsFromStream(stream, std::move(version),
-                                                   /*emit_errors=*/false,
-                                                   /*emit_metrics=*/true);
+  FirstPartySetParser::SetsAndAliases public_sets =
+      FirstPartySetParser::ParseSetsFromStream(stream, /*emit_errors=*/false,
+                                               /*emit_metrics=*/true);
+  sets_ = net::GlobalFirstPartySets(std::move(version),
+                                    std::move(public_sets.first),
+                                    std::move(public_sets.second));
 
   component_sets_parse_progress_ = Progress::kFinished;
   UmaHistogramTimes(
@@ -113,7 +121,9 @@ void FirstPartySetsLoader::MaybeFinishLoading() {
       !manually_specified_set_.has_value()) {
     return;
   }
-  sets_->ApplyManuallySpecifiedSet(manually_specified_set_.value());
+  if (!manually_specified_set_->empty()) {
+    sets_->ApplyManuallySpecifiedSet(manually_specified_set_->GetSet());
+  }
   std::move(on_load_complete_).Run(std::move(sets_).value());
 }
 
diff --git a/content/browser/first_party_sets/first_party_sets_loader.h b/content/browser/first_party_sets/first_party_sets_loader.h
index 1c49082d2fb462b0974ddf1bf46c4a254582b3c4..151ae13e930b0dace6de02156077f491a61f8256 100644
--- a/content/browser/first_party_sets/first_party_sets_loader.h
+++ b/content/browser/first_party_sets/first_party_sets_loader.h
@@ -12,9 +12,11 @@
 #include "base/sequence_checker.h"
 #include "base/thread_annotations.h"
 #include "base/timer/elapsed_timer.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/common/content_export.h"
 #include "net/first_party_sets/global_first_party_sets.h"
 #include "net/first_party_sets/local_set_declaration.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace content {
 
@@ -37,7 +39,7 @@ class CONTENT_EXPORT FirstPartySetsLoader {
 
   // Stores the First-Party Set that was provided via the `kUseFirstPartySet`
   // flag/switch. Only the first call has any effect.
-  void SetManuallySpecifiedSet(const net::LocalSetDeclaration& local_set);
+  void SetManuallySpecifiedSet(const LocalSetDeclaration& local_set);
 
   // Asynchronously parses and stores the sets from `sets_file`, and merges with
   // any previously-loaded sets as needed. In case of invalid input, the set of
@@ -66,7 +68,7 @@ class CONTENT_EXPORT FirstPartySetsLoader {
 
   // Holds the set that was provided on the command line (if any). This is
   // nullopt until `SetManuallySpecifiedSet` is called.
-  std::optional<net::LocalSetDeclaration> manually_specified_set_
+  absl::optional<LocalSetDeclaration> manually_specified_set_
       GUARDED_BY_CONTEXT(sequence_checker_);
 
   enum Progress {
diff --git a/content/browser/first_party_sets/local_set_declaration.cc b/content/browser/first_party_sets/local_set_declaration.cc
new file mode 100644
index 0000000000000000000000000000000000000000..ec77f974a1ffad3fcb8ceb027eeb2c009dfed79c
--- /dev/null
+++ b/content/browser/first_party_sets/local_set_declaration.cc
@@ -0,0 +1,89 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/first_party_sets/local_set_declaration.h"
+
+#include <sstream>
+#include <string>
+
+#include "base/logging.h"
+#include "base/ranges/algorithm.h"
+#include "content/browser/first_party_sets/first_party_set_parser.h"
+#include "net/base/schemeful_site.h"
+#include "net/first_party_sets/first_party_set_entry.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+
+namespace content {
+
+namespace {
+
+absl::optional<FirstPartySetParser::SingleSet> CanonicalizeSet(
+    const std::string& use_first_party_set_flag_value) {
+  std::istringstream stream(use_first_party_set_flag_value);
+
+  FirstPartySetParser::SetsAndAliases parsed =
+      FirstPartySetParser::ParseSetsFromStream(stream, /*emit_errors=*/true,
+                                               /*emit_metrics*/ false);
+
+  FirstPartySetParser::SetsMap entries = std::move(parsed.first);
+  FirstPartySetParser::Aliases aliases = std::move(parsed.second);
+
+  if (entries.empty()) {
+    return absl::nullopt;
+  }
+
+  const net::SchemefulSite primary = entries.begin()->second.primary();
+
+  if (base::ranges::any_of(
+          entries,
+          [&primary](const FirstPartySetParser::SetsMap::value_type& pair) {
+            return pair.second.primary() != primary;
+          })) {
+    // More than one set was provided. That is (currently) unsupported.
+    LOG(ERROR) << "Ignoring use-related-website-set switch due to multiple set "
+                  "declarations.";
+    return absl::nullopt;
+  }
+
+  for (const auto& [alias, canonical] : aliases) {
+    auto it = entries.find(canonical);
+    CHECK(it != entries.end());
+    bool inserted = entries.emplace(alias, it->second).second;
+    CHECK(inserted);
+  }
+
+  return absl::make_optional(std::move(entries));
+}
+
+}  // namespace
+
+LocalSetDeclaration::LocalSetDeclaration()
+    : LocalSetDeclaration(absl::nullopt) {}
+
+LocalSetDeclaration::LocalSetDeclaration(
+    const std::string& use_first_party_set_flag_value)
+    : LocalSetDeclaration(CanonicalizeSet(use_first_party_set_flag_value)) {}
+
+LocalSetDeclaration::LocalSetDeclaration(
+    absl::optional<FirstPartySetParser::SingleSet> parsed_set)
+    : parsed_set_(std::move(parsed_set)) {}
+
+LocalSetDeclaration::~LocalSetDeclaration() = default;
+
+LocalSetDeclaration::LocalSetDeclaration(const LocalSetDeclaration&) = default;
+LocalSetDeclaration& LocalSetDeclaration::operator=(
+    const LocalSetDeclaration&) = default;
+
+LocalSetDeclaration::LocalSetDeclaration(LocalSetDeclaration&&) = default;
+LocalSetDeclaration& LocalSetDeclaration::operator=(LocalSetDeclaration&&) =
+    default;
+
+const FirstPartySetParser::SingleSet& LocalSetDeclaration::GetSet() const {
+  CHECK(!empty());
+  const FirstPartySetParser::SingleSet& set = parsed_set_.value();
+  CHECK(!set.empty());
+  return set;
+}
+
+}  // namespace content
diff --git a/content/browser/first_party_sets/local_set_declaration.h b/content/browser/first_party_sets/local_set_declaration.h
new file mode 100644
index 0000000000000000000000000000000000000000..7d1e3e6dd810a81d2abdd9a5cbfaa8faef277f77
--- /dev/null
+++ b/content/browser/first_party_sets/local_set_declaration.h
@@ -0,0 +1,48 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_FIRST_PARTY_SETS_LOCAL_SET_DECLARATION_H_
+#define CONTENT_BROWSER_FIRST_PARTY_SETS_LOCAL_SET_DECLARATION_H_
+
+#include <string>
+
+#include "content/browser/first_party_sets/first_party_set_parser.h"
+#include "content/common/content_export.h"
+
+namespace content {
+
+class CONTENT_EXPORT LocalSetDeclaration {
+ public:
+  LocalSetDeclaration();
+
+  explicit LocalSetDeclaration(
+      const std::string& use_first_party_set_flag_value);
+
+  ~LocalSetDeclaration();
+
+  LocalSetDeclaration(const LocalSetDeclaration&);
+  LocalSetDeclaration& operator=(const LocalSetDeclaration&);
+  LocalSetDeclaration(LocalSetDeclaration&&);
+  LocalSetDeclaration& operator=(LocalSetDeclaration&&);
+
+  bool empty() const { return !parsed_set_.has_value(); }
+
+  size_t size() const { return empty() ? 0 : GetSet().size(); }
+
+  // Gets the set entries. Must not be called if `empty()` returns true.
+  const FirstPartySetParser::SingleSet& GetSet() const;
+
+ private:
+  explicit LocalSetDeclaration(
+      absl::optional<FirstPartySetParser::SingleSet> parsed_set);
+
+  // Stores the result of parsing the inputs. Specifically, this may be empty if
+  // no set was locally defined; otherwise, it holds the collection of
+  // FirstPartySetEntries and any ccTLD aliases.
+  absl::optional<FirstPartySetParser::SingleSet> parsed_set_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_FIRST_PARTY_SETS_LOCAL_SET_DECLARATION_H_
diff --git a/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.cc b/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.cc
index d9325e80b26c9aba49c5d71fc49daeac14933685..e3b2f0428a1ff0234326cc30bcd5a724c7c231be 100644
--- a/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.cc
+++ b/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.cc
@@ -44,7 +44,7 @@ ScopedMockFirstPartySetsHandler::FindEntry(
 
 void ScopedMockFirstPartySetsHandler::Init(
     const base::FilePath& user_data_dir,
-    const net::LocalSetDeclaration& local_set) {}
+    const LocalSetDeclaration& local_set) {}
 
 [[nodiscard]] std::optional<net::GlobalFirstPartySets>
 ScopedMockFirstPartySetsHandler::GetSets(
diff --git a/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.h b/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.h
index 5df5104bf47270a038de4e188ac2592adccf590f..de44481760169c409369d38ff48edc84d194b34f 100644
--- a/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.h
+++ b/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.h
@@ -7,6 +7,7 @@
 
 #include <optional>
 #include <string>
+#include <utility>
 
 #include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
@@ -67,8 +68,8 @@ class ScopedMockFirstPartySetsHandler
                              const net::FirstPartySetEntry&)> f) const override;
   // FirstPartySetsHandlerImpl:
   void Init(const base::FilePath& user_data_dir,
-            const net::LocalSetDeclaration& local_set) override;
-  [[nodiscard]] std::optional<net::GlobalFirstPartySets> GetSets(
+            const LocalSetDeclaration& local_set) override;
+  [[nodiscard]] absl::optional<net::GlobalFirstPartySets> GetSets(
       base::OnceCallback<void(net::GlobalFirstPartySets)> callback) override;
 
   // Helper functions for tests to set up context.
diff --git a/google_apis/gaia/oauth2_mint_token_flow.cc b/google_apis/gaia/oauth2_mint_token_flow.cc
index 4d7761e1d66665d4dbaa9d6b46f38fb0e2cfb288..ca7bf54fd1610619105b08e0041a81415e2df547 100644
--- a/google_apis/gaia/oauth2_mint_token_flow.cc
+++ b/google_apis/gaia/oauth2_mint_token_flow.cc
@@ -474,7 +474,7 @@ bool OAuth2MintTokenFlow::ParseRemoteConsentResponse(
               is_secure ? *is_secure : false,
               is_http_only ? *is_http_only : false,
               net::StringToCookieSameSite(same_site ? *same_site : ""),
-              net::COOKIE_PRIORITY_DEFAULT,
+              net::COOKIE_PRIORITY_DEFAULT, /* same_party */ false,
               /* partition_key */ std::nullopt);
       cookies.push_back(*cookie);
     }
diff --git a/google_apis/gaia/oauth_multilogin_result.cc b/google_apis/gaia/oauth_multilogin_result.cc
index 22a559059bc033ab3b2abd8a39e10671dd445cd4..be37adbd30714ee9fc6176f979ccba81d3713e2c 100644
--- a/google_apis/gaia/oauth_multilogin_result.cc
+++ b/google_apis/gaia/oauth_multilogin_result.cc
@@ -105,6 +105,7 @@ void OAuthMultiloginResult::TryParseCookiesFromValue(
     const std::string* priority = cookie_dict.FindString("priority");
     std::optional<double> expiration_delta = cookie_dict.FindDouble("maxAge");
     const std::string* same_site = cookie_dict.FindString("sameSite");
+    const std::string* same_party = cookie_dict.FindString("sameParty");
 
     base::Time now = base::Time::Now();
     // TODO(crbug.com/1264458) If CreateSanitizedCookie were used below, this
@@ -130,6 +131,7 @@ void OAuthMultiloginResult::TryParseCookiesFromValue(
       samesite_mode = net::StringToCookieSameSite(*same_site, &samesite_string);
     }
     net::RecordCookieSameSiteAttributeValueHistogram(samesite_string);
+    bool same_party_bool = same_party && (*same_party == "1");
     // TODO(crbug.com/1155648) Consider using CreateSanitizedCookie instead.
     std::unique_ptr<net::CanonicalCookie> new_cookie =
         net::CanonicalCookie::FromStorage(
@@ -138,8 +140,8 @@ void OAuthMultiloginResult::TryParseCookiesFromValue(
             /*last_access=*/now, /*last_update=*/now, is_secure.value_or(true),
             is_http_only.value_or(true), samesite_mode,
             net::StringToCookiePriority(priority ? *priority : "medium"),
-            /*partition_key=*/std::nullopt, net::CookieSourceScheme::kUnset,
-            url::PORT_UNSPECIFIED);
+            same_party_bool, /*partition_key=*/std::nullopt,
+            net::CookieSourceScheme::kUnset, url::PORT_UNSPECIFIED);
     // If the unique_ptr is null, it means the cookie was not canonical.
     // FromStorage() also uses a less strict version of IsCanonical(), we need
     // to check the stricter version as well here.
diff --git a/net/cookies/canonical_cookie.cc b/net/cookies/canonical_cookie.cc
index 02636104eae6d2223d637a11a89f92fcaf1497cc..a9bffaaeba95951ef4ac2a5115f41082e9103f53 100644
--- a/net/cookies/canonical_cookie.cc
+++ b/net/cookies/canonical_cookie.cc
@@ -393,6 +393,7 @@ CanonicalCookie::CanonicalCookie(
     bool httponly,
     CookieSameSite same_site,
     CookiePriority priority,
+    bool same_party,
     absl::optional<CookiePartitionKey> partition_key,
     CookieSourceScheme source_scheme,
     int source_port)
@@ -408,6 +409,7 @@ CanonicalCookie::CanonicalCookie(
       httponly_(httponly),
       same_site_(same_site),
       priority_(priority),
+      same_party_(same_party),
       partition_key_(std::move(partition_key)),
       source_scheme_(source_scheme),
       source_port_(source_port) {}
@@ -715,7 +717,8 @@ std::unique_ptr<CanonicalCookie> CanonicalCookie::Create(
       cookie_expires, creation_time,
       /*last_update=*/base::Time::Now(), parsed_cookie.IsSecure(),
       parsed_cookie.IsHttpOnly(), samesite, parsed_cookie.Priority(),
-      cookie_partition_key, source_scheme, source_port);
+      parsed_cookie.IsSameParty(), cookie_partition_key, source_scheme,
+      source_port);
 
   // TODO(chlily): Log metrics.
   if (!cc->IsCanonical()) {
@@ -762,6 +765,7 @@ std::unique_ptr<CanonicalCookie> CanonicalCookie::CreateSanitizedCookie(
     bool http_only,
     CookieSameSite same_site,
     CookiePriority priority,
+    bool same_party,
     absl::optional<CookiePartitionKey> partition_key,
     CookieInclusionStatus* status) {
   // Put a pointer on the stack so the rest of the function can assign to it if
@@ -931,7 +935,7 @@ std::unique_ptr<CanonicalCookie> CanonicalCookie::CreateSanitizedCookie(
       base::PassKey<CanonicalCookie>(), name, value, cookie_domain,
       encoded_cookie_path, creation_time, expiration_time, last_access_time,
       /*last_update=*/base::Time::Now(), secure, http_only, same_site, priority,
-      partition_key, source_scheme, source_port);
+      same_party, partition_key, source_scheme, source_port);
   DCHECK(cc->IsCanonical());
 
   return cc;
@@ -951,6 +955,7 @@ std::unique_ptr<CanonicalCookie> CanonicalCookie::FromStorage(
     bool httponly,
     CookieSameSite same_site,
     CookiePriority priority,
+    bool same_party,
     absl::optional<CookiePartitionKey> partition_key,
     CookieSourceScheme source_scheme,
     int source_port) {
@@ -965,8 +970,8 @@ std::unique_ptr<CanonicalCookie> CanonicalCookie::FromStorage(
   auto cc = std::make_unique<CanonicalCookie>(
       base::PassKey<CanonicalCookie>(), std::move(name), std::move(value),
       std::move(domain), std::move(path), creation, expiration, last_access,
-      last_update, secure, httponly, same_site, priority, partition_key,
-      source_scheme, validated_port);
+      last_update, secure, httponly, same_site, priority, same_party,
+      partition_key, source_scheme, validated_port);
 
   if (cc->IsCanonicalForFromStorage()) {
     // This will help capture the number of times a cookie is canonical but does
@@ -996,13 +1001,14 @@ std::unique_ptr<CanonicalCookie> CanonicalCookie::CreateUnsafeCookieForTesting(
     bool httponly,
     CookieSameSite same_site,
     CookiePriority priority,
+    bool same_party,
     absl::optional<CookiePartitionKey> partition_key,
     CookieSourceScheme source_scheme,
     int source_port) {
   return std::make_unique<CanonicalCookie>(
       base::PassKey<CanonicalCookie>(), name, value, domain, path, creation,
       expiration, last_access, last_update, secure, httponly, same_site,
-      priority, partition_key, source_scheme, source_port);
+      priority, same_party, partition_key, source_scheme, source_port);
 }
 
 bool CanonicalCookie::IsFirstPartyPartitioned() const {
@@ -1252,6 +1258,7 @@ CookieAccessResult CanonicalCookie::IncludeForRequestURL(
         CookieInclusionStatus::EXCLUDE_SAMESITE_NONE_INSECURE);
   }
 
+  // Only apply SameSite-related warnings if SameParty is not in effect.
   ApplySameSiteCookieWarningToStatus(SameSite(), effective_same_site,
                                      IsSecure(),
                                      options.same_site_cookie_context(),
@@ -1425,6 +1432,7 @@ CookieAccessResult CanonicalCookie::IsSetPermittedInContext(
       break;
   }
 
+  // Only apply SameSite-related warnings if SameParty is not in effect.
   ApplySameSiteCookieWarningToStatus(
       SameSite(), access_result.effective_same_site, IsSecure(),
       options.same_site_cookie_context(), &access_result.status,
diff --git a/net/cookies/canonical_cookie.h b/net/cookies/canonical_cookie.h
index 599b17b834e6816f05f029014e2e53cb067a318d..85a7770eebd2e503257425a9b65ff37728ddd904 100644
--- a/net/cookies/canonical_cookie.h
+++ b/net/cookies/canonical_cookie.h
@@ -107,6 +107,7 @@ class NET_EXPORT CanonicalCookie {
                   bool httponly,
                   CookieSameSite same_site,
                   CookiePriority priority,
+                  bool same_party,
                   absl::optional<CookiePartitionKey> partition_key,
                   CookieSourceScheme scheme_secure = CookieSourceScheme::kUnset,
                   int source_port = url::PORT_UNSPECIFIED);
@@ -167,6 +168,7 @@ class NET_EXPORT CanonicalCookie {
       bool http_only,
       CookieSameSite same_site,
       CookiePriority priority,
+      bool same_party,
       absl::optional<CookiePartitionKey> partition_key,
       CookieInclusionStatus* status = nullptr);
 
@@ -190,6 +192,7 @@ class NET_EXPORT CanonicalCookie {
       bool httponly,
       CookieSameSite same_site,
       CookiePriority priority,
+      bool same_party,
       absl::optional<CookiePartitionKey> partition_key,
       CookieSourceScheme source_scheme,
       int source_port);
@@ -209,6 +212,7 @@ class NET_EXPORT CanonicalCookie {
       bool httponly,
       CookieSameSite same_site,
       CookiePriority priority,
+      bool same_party,
       absl::optional<CookiePartitionKey> partition_key = absl::nullopt,
       CookieSourceScheme scheme_secure = CookieSourceScheme::kUnset,
       int source_port = url::PORT_UNSPECIFIED);
@@ -240,6 +244,7 @@ class NET_EXPORT CanonicalCookie {
   bool IsHttpOnly() const { return httponly_; }
   CookieSameSite SameSite() const { return same_site_; }
   CookiePriority Priority() const { return priority_; }
+  bool IsSameParty() const { return same_party_; }
   bool IsPartitioned() const { return partition_key_.has_value(); }
   const absl::optional<CookiePartitionKey>& PartitionKey() const {
     return partition_key_;
@@ -366,7 +371,7 @@ class NET_EXPORT CanonicalCookie {
            last_access_date_ == other.last_access_date_ &&
            expiry_date_ == other.expiry_date_ && secure_ == other.secure_ &&
            httponly_ == other.httponly_ && same_site_ == other.same_site_ &&
-           priority_ == other.priority_ &&
+           priority_ == other.priority_ && same_party_ == other.same_party_ &&
            partition_key_ == other.partition_key_ && name_ == other.name_ &&
            value_ == other.value_ && domain_ == other.domain_ &&
            path_ == other.path_ &&
@@ -380,8 +385,9 @@ class NET_EXPORT CanonicalCookie {
     auto f = [](const CanonicalCookie& c) {
       return std::tie(c.creation_date_, c.last_access_date_, c.expiry_date_,
                       c.secure_, c.httponly_, c.same_site_, c.priority_,
-                      c.partition_key_, c.name_, c.value_, c.domain_, c.path_,
-                      c.last_update_date_, c.source_scheme_, c.source_port_);
+                      c.same_party_, c.partition_key_, c.name_, c.value_,
+                      c.domain_, c.path_, c.last_update_date_, c.source_scheme_,
+                      c.source_port_);
     };
     return f(*this) < f(other);
   }
@@ -628,6 +634,7 @@ class NET_EXPORT CanonicalCookie {
   bool httponly_{false};
   CookieSameSite same_site_{CookieSameSite::NO_RESTRICTION};
   CookiePriority priority_{COOKIE_PRIORITY_MEDIUM};
+  bool same_party_{false};
   // This will be absl::nullopt for all cookies not set with the Partitioned
   // attribute or without a nonce. If the value is non-null, then the cookie
   // will only be delivered when the top-frame site matches the partition key
diff --git a/net/cookies/canonical_cookie_fuzzer.cc b/net/cookies/canonical_cookie_fuzzer.cc
index c2113af5acc47b720e13d9ddf605a1e223bcc420..0df06e5022a675de884ee35e69b5fcd17efa7ca7 100644
--- a/net/cookies/canonical_cookie_fuzzer.cc
+++ b/net/cookies/canonical_cookie_fuzzer.cc
@@ -66,7 +66,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
           url, name, value, domain, path, creation, expiration, last_access,
           data_provider.ConsumeBool() /* secure */,
           data_provider.ConsumeBool() /* httponly */, same_site, priority,
-          partition_key);
+          data_provider.ConsumeBool() /* same_party */, partition_key);
 
   if (sanitized_cookie) {
     CHECK(sanitized_cookie->IsCanonical());
diff --git a/net/cookies/cookie_inclusion_status.h b/net/cookies/cookie_inclusion_status.h
index 98d8012e544a537da8f0bd51a03bcda230178d78..840b0187c984a9e4bbe66e35e1fdb6e871d6a583 100644
--- a/net/cookies/cookie_inclusion_status.h
+++ b/net/cookies/cookie_inclusion_status.h
@@ -78,7 +78,8 @@ class NET_EXPORT CookieInclusionStatus {
     // Cookie was set with an invalid __Host- or __Secure- prefix.
     EXCLUDE_INVALID_PREFIX = 15,
     /// Cookie was set with an invalid Partitioned attribute, which is only
-    // valid if the cookie has a __Host- prefix.
+    // valid if the cookie has a __Host- prefix and does not have the SameParty
+    // attribute.
     EXCLUDE_INVALID_PARTITIONED = 16,
     // Cookie exceeded the name/value pair size limit.
     EXCLUDE_NAME_VALUE_PAIR_EXCEEDS_MAX_SIZE = 17,
@@ -378,7 +379,9 @@ class NET_EXPORT CookieInclusionStatus {
 
   // Returns true if the cookie was excluded because of user preferences.
   // HasOnlyExclusionReason(EXCLUDE_USER_PREFERENCES) will not return true for
-  // third-party cookies blocked in sites in the same First-Party Set. See
+  // third-party cookies blocked in sites in the same First-Party Set (note:
+  // this is not the same as the cookie being blocked in a same-party context,
+  // which takes the entire ancestor chain into account). See
   // https://crbug.com/1366868.
   bool ExcludedByUserPreferences() const;
 
diff --git a/net/cookies/cookie_monster_netlog_params.cc b/net/cookies/cookie_monster_netlog_params.cc
index 667920356812c6675ae2ce4f83ab0ecf85df0abe..7f766060610af6056480ec241b6a4f03d4fb0be2 100644
--- a/net/cookies/cookie_monster_netlog_params.cc
+++ b/net/cookies/cookie_monster_netlog_params.cc
@@ -33,6 +33,7 @@ base::Value::Dict NetLogCookieMonsterCookieAdded(
   dict.Set("same_site", CookieSameSiteToString(cookie->SameSite()));
   dict.Set("is_persistent", cookie->IsPersistent());
   dict.Set("sync_requested", sync_requested);
+  dict.Set("same_party", cookie->IsSameParty());
   return dict;
 }
 
diff --git a/net/cookies/cookie_options.h b/net/cookies/cookie_options.h
index b240265067e9ee72f8f15092a5fb63aed9c0d563..183c1f61c1fbe94c8c85dd4f9a27695a04aad816 100644
--- a/net/cookies/cookie_options.h
+++ b/net/cookies/cookie_options.h
@@ -228,12 +228,14 @@ class NET_EXPORT CookieOptions {
   // * Excludes SameSite cookies
   // * Updates last-accessed time.
   // * Does not report excluded cookies in APIs that can do so.
+  // * Excludes SameParty cookies.
   //
   // These settings can be altered by calling:
   //
   // * |set_{include,exclude}_httponly()|
   // * |set_same_site_cookie_context()|
   // * |set_do_not_update_access_time()|
+  // * |set_same_party_cookie_context_type()|
   CookieOptions();
   CookieOptions(const CookieOptions& other);
   CookieOptions(CookieOptions&& other);
diff --git a/net/cookies/parse_cookie_line_fuzzer.cc b/net/cookies/parse_cookie_line_fuzzer.cc
index ebc3fc7278667217816fd24993b3edc5579e2454..736311afbe8a06a87a4d2b0207dbdcbfc03c2ca4 100644
--- a/net/cookies/parse_cookie_line_fuzzer.cc
+++ b/net/cookies/parse_cookie_line_fuzzer.cc
@@ -36,7 +36,7 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
 
   // Call zero or one of ParsedCookie's mutator methods.  Should not call
   // anything other than SetName/SetValue when !IsValid().
-  const uint8_t action = data_provider.ConsumeIntegralInRange(0, 11);
+  const uint8_t action = data_provider.ConsumeIntegralInRange(0, 12);
   switch (action) {
     case 1:
       parsed_cookie.SetName(GetArbitraryNameValueString(&data_provider));
@@ -80,6 +80,9 @@ extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
             GetArbitraryAttributeValueString(&data_provider));
         break;
       case 11:
+        parsed_cookie.SetIsSameParty(data_provider.ConsumeBool());
+        break;
+      case 12:
         parsed_cookie.SetIsPartitioned(data_provider.ConsumeBool());
         break;
     }
diff --git a/net/cookies/parsed_cookie.cc b/net/cookies/parsed_cookie.cc
index 24b36dd569a325e20354ce90d07035c2f112864c..8998acd3e25ac39013c835fb046f37e6d9fa007d 100644
--- a/net/cookies/parsed_cookie.cc
+++ b/net/cookies/parsed_cookie.cc
@@ -63,6 +63,7 @@ const char kSecureTokenName[] = "secure";
 const char kHttpOnlyTokenName[] = "httponly";
 const char kSameSiteTokenName[] = "samesite";
 const char kPriorityTokenName[] = "priority";
+const char kSamePartyTokenName[] = "sameparty";
 const char kPartitionedTokenName[] = "partitioned";
 
 const char kTerminator[] = "\n\r\0";
@@ -270,6 +271,10 @@ bool ParsedCookie::SetPriority(const std::string& priority) {
   return SetString(&priority_index_, kPriorityTokenName, priority);
 }
 
+bool ParsedCookie::SetIsSameParty(bool is_same_party) {
+  return SetBool(&same_party_index_, kSamePartyTokenName, is_same_party);
+}
+
 bool ParsedCookie::SetIsPartitioned(bool is_partitioned) {
   return SetBool(&partitioned_index_, kPartitionedTokenName, is_partitioned);
 }
@@ -285,6 +290,7 @@ std::string ParsedCookie::ToCookieLine() const {
     // we need to consider whether the name component is a special token.
     if (it == pairs_.begin() ||
         (it->first != kSecureTokenName && it->first != kHttpOnlyTokenName &&
+         it->first != kSamePartyTokenName &&
          it->first != kPartitionedTokenName)) {
       out.append("=");
       out.append(it->second);
@@ -668,6 +674,8 @@ void ParsedCookie::SetupAttributes() {
       same_site_index_ = i;
     } else if (pairs_[i].first == kPriorityTokenName) {
       priority_index_ = i;
+    } else if (pairs_[i].first == kSamePartyTokenName) {
+      same_party_index_ = i;
     } else if (pairs_[i].first == kPartitionedTokenName) {
       partitioned_index_ = i;
     } else {
@@ -741,10 +749,10 @@ void ParsedCookie::ClearAttributePair(size_t index) {
   if (index == 0)
     return;
 
-  size_t* indexes[] = {
-      &path_index_,      &domain_index_,   &expires_index_,
-      &maxage_index_,    &secure_index_,   &httponly_index_,
-      &same_site_index_, &priority_index_, &partitioned_index_};
+  size_t* indexes[] = {&path_index_,       &domain_index_,   &expires_index_,
+                       &maxage_index_,     &secure_index_,   &httponly_index_,
+                       &same_site_index_,  &priority_index_, &same_party_index_,
+                       &partitioned_index_};
   for (size_t* attribute_index : indexes) {
     if (*attribute_index == index)
       *attribute_index = 0;
diff --git a/net/cookies/parsed_cookie.h b/net/cookies/parsed_cookie.h
index ed84c8fc4328b5c96b84b40d3a56974cecb64c42..3fe624444cdf28a180cffce920dd3fd8057e368c 100644
--- a/net/cookies/parsed_cookie.h
+++ b/net/cookies/parsed_cookie.h
@@ -85,6 +85,7 @@ class NET_EXPORT ParsedCookie {
   CookieSameSite SameSite(
       CookieSameSiteString* samesite_string = nullptr) const;
   CookiePriority Priority() const;
+  bool IsSameParty() const { return same_party_index_ != 0; }
   bool IsPartitioned() const { return partitioned_index_ != 0; }
   bool HasInternalHtab() const { return internal_htab_; }
   TruncatingCharacterInCookieStringType
@@ -115,6 +116,7 @@ class NET_EXPORT ParsedCookie {
   bool SetIsHttpOnly(bool is_http_only);
   bool SetSameSite(const std::string& same_site);
   bool SetPriority(const std::string& priority);
+  bool SetIsSameParty(bool is_same_party);
   bool SetIsPartitioned(bool is_partitioned);
 
   // Returns the cookie description as it appears in a HTML response header.
@@ -211,6 +213,7 @@ class NET_EXPORT ParsedCookie {
   size_t httponly_index_ = 0;
   size_t same_site_index_ = 0;
   size_t priority_index_ = 0;
+  size_t same_party_index_ = 0;
   size_t partitioned_index_ = 0;
   TruncatingCharacterInCookieStringType truncating_char_in_cookie_string_type_ =
       TruncatingCharacterInCookieStringType::kTruncatingCharNone;
diff --git a/net/extras/sqlite/sqlite_persistent_cookie_store.cc b/net/extras/sqlite/sqlite_persistent_cookie_store.cc
index 0adc6857266535320dedbeee8881f50b14d213f1..920bac177582797f2f819e9f93f2a1d07e7d18a0 100644
--- a/net/extras/sqlite/sqlite_persistent_cookie_store.cc
+++ b/net/extras/sqlite/sqlite_persistent_cookie_store.cc
@@ -228,8 +228,8 @@ namespace {
 // Version 3 updated the database to include the last access time, so we can
 // expire them in decreasing order of use when we've reached the maximum
 // number of cookies.
-const int kCurrentVersionNumber = 21;
-const int kCompatibleVersionNumber = 21;
+const int kCurrentVersionNumber = 20;
+const int kCompatibleVersionNumber = 20;
 
 }  // namespace
 
@@ -685,45 +685,6 @@ bool CreateV20Schema(sql::Database* db) {
   return true;
 }
 
-bool CreateV21Schema(sql::Database* db) {
-  CHECK(!db->DoesTableExist("cookies"));
-
-  const char* kCreateTableQuery =
-      "CREATE TABLE cookies("
-      "creation_utc INTEGER NOT NULL,"
-      "host_key TEXT NOT NULL,"
-      "top_frame_site_key TEXT NOT NULL,"
-      "name TEXT NOT NULL,"
-      "value TEXT NOT NULL,"
-      "encrypted_value BLOB NOT NULL,"
-      "path TEXT NOT NULL,"
-      "expires_utc INTEGER NOT NULL,"
-      "is_secure INTEGER NOT NULL,"
-      "is_httponly INTEGER NOT NULL,"
-      "last_access_utc INTEGER NOT NULL,"
-      "has_expires INTEGER NOT NULL,"
-      "is_persistent INTEGER NOT NULL,"
-      "priority INTEGER NOT NULL,"
-      "samesite INTEGER NOT NULL,"
-      "source_scheme INTEGER NOT NULL,"
-      "source_port INTEGER NOT NULL,"
-      "last_update_utc INTEGER NOT NULL);";
-
-  const char* kCreateIndexQuery =
-      "CREATE UNIQUE INDEX cookies_unique_index "
-      "ON cookies(host_key, top_frame_site_key, name, path, source_scheme, "
-      "source_port)";
-
-  if (!db->Execute(kCreateTableQuery)) {
-    return false;
-  }
-  if (!db->Execute(kCreateIndexQuery)) {
-    return false;
-  }
-
-  return true;
-}
-
 }  // namespace
 
 void SQLitePersistentCookieStore::Backend::Load(
@@ -796,7 +757,7 @@ bool SQLitePersistentCookieStore::Backend::CreateDatabaseSchema() {
   if (db()->DoesTableExist("cookies"))
     return true;
 
-  return CreateV21Schema(db());
+  return CreateV20Schema(db());
 }
 
 bool SQLitePersistentCookieStore::Backend::DoInitializeDatabase() {
@@ -870,14 +831,14 @@ bool SQLitePersistentCookieStore::Backend::LoadCookiesForDomains(
         "SELECT creation_utc, host_key, top_frame_site_key, name, value, path, "
         "expires_utc, is_secure, is_httponly, last_access_utc, has_expires, "
         "is_persistent, priority, encrypted_value, samesite, source_scheme, "
-        "source_port, last_update_utc FROM cookies WHERE host_key = ?"));
+        "source_port, is_same_party, last_update_utc FROM cookies WHERE host_key = ?"));
   } else {
     smt.Assign(db()->GetCachedStatement(
         SQL_FROM_HERE,
         "SELECT creation_utc, host_key, top_frame_site_key, name, value, path, "
         "expires_utc, is_secure, is_httponly, last_access_utc, has_expires, "
         "is_persistent, priority, encrypted_value, samesite, source_scheme, "
-        "source_port, last_update_utc FROM cookies WHERE "
+        "source_port, is_same_party, last_update_utc FROM cookies WHERE "
         "host_key = ? AND "
         "is_persistent = 1"));
   }
@@ -984,13 +945,14 @@ bool SQLitePersistentCookieStore::Backend::MakeCookiesFromSQLStatement(
         statement.ColumnTime(0),    // creation_utc
         statement.ColumnTime(6),    // expires_utc
         statement.ColumnTime(9),    // last_access_utc
-        statement.ColumnTime(17),   // last_update_utc
+        statement.ColumnTime(18),   // last_update_utc
         statement.ColumnBool(7),    // secure
         statement.ColumnBool(8),    // http_only
         DBCookieSameSiteToCookieSameSite(static_cast<DBCookieSameSite>(
             statement.ColumnInt(14))),  // samesite
         DBCookiePriorityToCookiePriority(static_cast<DBCookiePriority>(
             statement.ColumnInt(12))),                    // priority
+        statement.ColumnBool(17),                         // is_same_party
         std::move(cookie_partition_key),                  // top_frame_site_key
         DBToCookieSourceScheme(statement.ColumnInt(15)),  // source_scheme
         statement.ColumnInt(16));                         // source_port
@@ -1225,55 +1187,6 @@ SQLitePersistentCookieStore::Backend::DoMigrateDatabaseSchema() {
     }
   }
 
-  if (cur_version == 20) {
-    SCOPED_UMA_HISTOGRAM_TIMER("Cookie.TimeDatabaseMigrationToV21");
-
-    sql::Transaction transaction(db());
-    if (!transaction.Begin()) {
-      return absl::nullopt;
-    }
-
-    if (!db()->Execute("DROP TABLE IF EXISTS cookies_old")) {
-      return absl::nullopt;
-    }
-    if (!db()->Execute("ALTER TABLE cookies RENAME TO cookies_old")) {
-      return absl::nullopt;
-    }
-    if (!db()->Execute("DROP INDEX IF EXISTS cookies_unique_index")) {
-      return absl::nullopt;
-    }
-
-    if (!CreateV21Schema(db())) {
-      return absl::nullopt;
-    }
-
-    static constexpr char insert_cookies_sql[] =
-        "INSERT OR REPLACE INTO cookies "
-        "(creation_utc, host_key, top_frame_site_key, name, value, "
-        "encrypted_value, path, expires_utc, is_secure, is_httponly, "
-        "last_access_utc, has_expires, is_persistent, priority, samesite, "
-        "source_scheme, source_port, last_update_utc) "
-        "SELECT creation_utc, host_key, top_frame_site_key, name, value,"
-        "       encrypted_value, path, expires_utc, is_secure, is_httponly,"
-        "       last_access_utc, has_expires, is_persistent, priority, "
-        "       samesite, source_scheme, source_port, last_update_utc "
-        "FROM cookies_old ORDER BY creation_utc ASC";
-    if (!db()->Execute(insert_cookies_sql)) {
-      return absl::nullopt;
-    }
-    if (!db()->Execute("DROP TABLE cookies_old")) {
-      return absl::nullopt;
-    }
-
-    ++cur_version;
-    if (!meta_table()->SetVersionNumber(cur_version) ||
-        !meta_table()->SetCompatibleVersionNumber(
-            std::min(cur_version, kCompatibleVersionNumber)) ||
-        !transaction.Commit()) {
-      return absl::nullopt;
-    }
-  }
-
   // Put future migration cases here.
 
   return absl::make_optional(cur_version);
@@ -1375,7 +1288,7 @@ void SQLitePersistentCookieStore::Backend::DoCommit() {
       "INSERT INTO cookies (creation_utc, host_key, top_frame_site_key, name, "
       "value, encrypted_value, path, expires_utc, is_secure, is_httponly, "
       "last_access_utc, has_expires, is_persistent, priority, samesite, "
-      "source_scheme, source_port, last_update_utc) "
+      "source_scheme, source_port, is_same_party, last_update_utc) "
       "VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"));
   if (!add_statement.is_valid())
     return;
@@ -1444,7 +1357,8 @@ void SQLitePersistentCookieStore::Backend::DoCommit() {
               14, CookieSameSiteToDBCookieSameSite(po->cc().SameSite()));
           add_statement.BindInt(15, static_cast<int>(po->cc().SourceScheme()));
           add_statement.BindInt(16, po->cc().SourcePort());
-          add_statement.BindTime(17, po->cc().LastUpdateDate());
+          add_statement.BindBool(17, po->cc().IsSameParty());
+          add_statement.BindTime(18, po->cc().LastUpdateDate());
           if (!add_statement.Run()) {
             DLOG(WARNING) << "Could not add a cookie to the DB.";
             RecordCookieCommitProblem(COOKIE_COMMIT_PROBLEM_ADD);
diff --git a/net/first_party_sets/global_first_party_sets.cc b/net/first_party_sets/global_first_party_sets.cc
index c916b0f4e106afdef92b3cd4d95cff3edf4d5594..10106c045eb8202d104288d687dd83194b5ba64b 100644
--- a/net/first_party_sets/global_first_party_sets.cc
+++ b/net/first_party_sets/global_first_party_sets.cc
@@ -19,7 +19,6 @@
 #include "net/first_party_sets/first_party_set_entry_override.h"
 #include "net/first_party_sets/first_party_set_metadata.h"
 #include "net/first_party_sets/first_party_sets_context_config.h"
-#include "net/first_party_sets/local_set_declaration.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace net {
@@ -76,29 +75,25 @@ GlobalFirstPartySets::GlobalFirstPartySets(
           public_sets_version.IsValid()
               ? std::move(aliases)
               : base::flat_map<SchemefulSite, SchemefulSite>(),
-          FirstPartySetsContextConfig(),
-          base::flat_map<SchemefulSite, SchemefulSite>()) {}
+          FirstPartySetsContextConfig()) {}
 
 GlobalFirstPartySets::GlobalFirstPartySets(
     base::Version public_sets_version,
     base::flat_map<SchemefulSite, FirstPartySetEntry> entries,
     base::flat_map<SchemefulSite, SchemefulSite> aliases,
-    FirstPartySetsContextConfig manual_config,
-    base::flat_map<SchemefulSite, SchemefulSite> manual_aliases)
+    FirstPartySetsContextConfig manual_config)
     : public_sets_version_(std::move(public_sets_version)),
       entries_(std::move(entries)),
       aliases_(std::move(aliases)),
-      manual_config_(std::move(manual_config)),
-      manual_aliases_(std::move(manual_aliases)) {
-  if (!public_sets_version_.IsValid()) {
+      manual_config_(std::move(manual_config)) {
+  if (public_sets_version_.IsValid()) {
+    CHECK(base::ranges::all_of(aliases_, [&](const auto& pair) {
+      return entries_.contains(pair.second);
+    }));
+  } else {
     CHECK(entries_.empty());
     CHECK(aliases_.empty());
   }
-
-  CHECK(base::ranges::all_of(aliases_, [&](const auto& pair) {
-    return entries_.contains(pair.second);
-  }));
-  CHECK(!ContainsSingleton());
 }
 
 GlobalFirstPartySets::GlobalFirstPartySets(GlobalFirstPartySets&&) = default;
@@ -107,15 +102,18 @@ GlobalFirstPartySets& GlobalFirstPartySets::operator=(GlobalFirstPartySets&&) =
 
 GlobalFirstPartySets::~GlobalFirstPartySets() = default;
 
-bool GlobalFirstPartySets::operator==(const GlobalFirstPartySets& other) const =
-    default;
+bool GlobalFirstPartySets::operator==(const GlobalFirstPartySets& other) const {
+  return std::tie(public_sets_version_, entries_, aliases_, manual_config_) ==
+         std::tie(other.public_sets_version_, other.entries_, other.aliases_,
+                  other.manual_config_);
+}
 
 bool GlobalFirstPartySets::operator!=(const GlobalFirstPartySets& other) const =
     default;
 
 GlobalFirstPartySets GlobalFirstPartySets::Clone() const {
   return GlobalFirstPartySets(public_sets_version_, entries_, aliases_,
-                              manual_config_.Clone(), manual_aliases_);
+                              manual_config_.Clone());
 }
 
 absl::optional<FirstPartySetEntry> GlobalFirstPartySets::FindEntry(
@@ -184,31 +182,12 @@ FirstPartySetMetadata GlobalFirstPartySets::ComputeMetadata(
 }
 
 void GlobalFirstPartySets::ApplyManuallySpecifiedSet(
-    const LocalSetDeclaration& local_set_declaration) {
+    const base::flat_map<SchemefulSite, FirstPartySetEntry>& manual_entries) {
   CHECK(manual_config_.empty());
-  CHECK(manual_aliases_.empty());
-  if (local_set_declaration.empty()) {
-    // Nothing to do.
-    return;
-  }
-
-  base::flat_map<SchemefulSite, SchemefulSite> manual_aliases =
-      local_set_declaration.aliases();
-
-  base::flat_map<SchemefulSite, FirstPartySetEntry> manual_entries =
-      local_set_declaration.entries();
-  for (const auto& [alias, canonical] : manual_aliases) {
-    manual_entries.emplace(alias, manual_entries.find(canonical)->second);
-  }
-
   // We handle the manually-specified set the same way as we handle
   // replacement enterprise policy sets.
-  manual_config_ = ComputeConfig(SetsMutation(
-      /*replacement_sets=*/{manual_entries},
-      /*addition_sets=*/{}));
-  manual_aliases_ = std::move(manual_aliases);
-
-  CHECK(!ContainsSingleton());
+  manual_config_ = ComputeConfig(
+      /*replacement_sets=*/{manual_entries}, /*addition_sets=*/{});
 }
 
 void GlobalFirstPartySets::UnsafeSetManualConfig(
@@ -218,9 +197,8 @@ void GlobalFirstPartySets::UnsafeSetManualConfig(
 }
 
 FirstPartySetsContextConfig GlobalFirstPartySets::ComputeConfig(
-    const SetsMutation& mutation) const {
-  const std::vector<SingleSet>& replacement_sets = mutation.replacements();
-  const std::vector<SingleSet>& addition_sets = mutation.additions();
+    const std::vector<SingleSet>& replacement_sets,
+    const std::vector<SingleSet>& addition_sets) const {
   if (base::ranges::all_of(replacement_sets,
                            [](const SingleSet& set) { return set.empty(); }) &&
       base::ranges::all_of(addition_sets,
@@ -334,15 +312,14 @@ FirstPartySetsContextConfig GlobalFirstPartySets::ComputeConfig(
     }
   }
 
-  // For every pre-existing alias that would now refer to a site in the overlay,
-  // which is not already contained in the overlay, we explicitly ignore that
-  // alias.
-  ForEachAlias([&](const SchemefulSite& alias, const SchemefulSite& canonical) {
-    if (base::Contains(site_to_entry, canonical, ProjectKey) &&
+  // For every public alias that would now refer to a site in the overlay, which
+  // is not already contained in the overlay, we explicitly ignore that alias.
+  for (const auto& [alias, site] : aliases_) {
+    if (base::Contains(site_to_entry, site, ProjectKey) &&
         !base::Contains(site_to_entry, alias, ProjectKey)) {
       site_to_entry.emplace_back(alias, FirstPartySetEntryOverride());
     }
-  });
+  }
 
   return FirstPartySetsContextConfig(std::move(site_to_entry));
 }
@@ -466,42 +443,6 @@ bool GlobalFirstPartySets::ForEachEffectiveSetEntry(
   });
 }
 
-void GlobalFirstPartySets::ForEachAlias(
-    base::FunctionRef<void(const SchemefulSite&, const SchemefulSite&)> f)
-    const {
-  for (const auto& [alias, site] : manual_aliases_) {
-    f(alias, site);
-  }
-  for (const auto& [alias, site] : aliases_) {
-    if (manual_config_.Contains(alias)) {
-      continue;
-    }
-    f(alias, site);
-  }
-}
-
-bool GlobalFirstPartySets::ContainsSingleton() const {
-  std::set<SchemefulSite> possible_singletons;
-  std::set<SchemefulSite> not_singletons;
-
-  ForEachEffectiveSetEntry(
-      nullptr,
-      [&](const SchemefulSite& site, const FirstPartySetEntry& entry) -> bool {
-        if (!not_singletons.contains(entry.primary())) {
-          if (site == entry.primary()) {
-            possible_singletons.insert(entry.primary());
-          } else {
-            not_singletons.insert(entry.primary());
-            possible_singletons.erase(entry.primary());
-          }
-        }
-
-        return true;
-      });
-
-  return !possible_singletons.empty();
-}
-
 std::ostream& operator<<(std::ostream& os, const GlobalFirstPartySets& sets) {
   os << "{entries = {";
   for (const auto& [site, entry] : sets.entries_) {
@@ -518,10 +459,6 @@ std::ostream& operator<<(std::ostream& os, const GlobalFirstPartySets& sets) {
         os << "{" << site.Serialize() << ": " << override << "},";
         return true;
       });
-  os << "}, manual_aliases = {";
-  for (const auto& [alias, canonical] : sets.manual_aliases_) {
-    os << "{" << alias.Serialize() << ": " << canonical.Serialize() << "}, ";
-  }
   os << "}}";
   return os;
 }
diff --git a/net/first_party_sets/global_first_party_sets.h b/net/first_party_sets/global_first_party_sets.h
index d87aaec1747738a29dc03cdfcb9266c48ef8b699..f4f4e99189e0f3b8accfa884e136a127d0128bab 100644
--- a/net/first_party_sets/global_first_party_sets.h
+++ b/net/first_party_sets/global_first_party_sets.h
@@ -5,6 +5,8 @@
 #ifndef NET_FIRST_PARTY_SETS_GLOBAL_FIRST_PARTY_SETS_H_
 #define NET_FIRST_PARTY_SETS_GLOBAL_FIRST_PARTY_SETS_H_
 
+#include <set>
+
 #include "base/containers/flat_map.h"
 #include "base/containers/flat_set.h"
 #include "base/functional/function_ref.h"
@@ -14,8 +16,6 @@
 #include "net/first_party_sets/first_party_set_entry.h"
 #include "net/first_party_sets/first_party_set_entry_override.h"
 #include "net/first_party_sets/first_party_sets_context_config.h"
-#include "net/first_party_sets/local_set_declaration.h"
-#include "net/first_party_sets/sets_mutation.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace mojo {
@@ -55,8 +55,15 @@ class NET_EXPORT GlobalFirstPartySets {
   GlobalFirstPartySets Clone() const;
 
   // Returns a FirstPartySetsContextConfig that respects the overrides given by
-  // `mutation`, relative to this instance's state.
-  FirstPartySetsContextConfig ComputeConfig(const SetsMutation& mutation) const;
+  // `replacement_sets` and `addition_sets`, relative to this instance's state.
+  //
+  // Preconditions: sets defined by `replacement_sets` and
+  // `addition_sets` must be disjoint.
+  FirstPartySetsContextConfig ComputeConfig(
+      const std::vector<base::flat_map<SchemefulSite, FirstPartySetEntry>>&
+          replacement_sets,
+      const std::vector<base::flat_map<SchemefulSite, FirstPartySetEntry>>&
+          addition_sets) const;
 
   // Returns the entry corresponding to the given `site`, if one exists.
   // Respects any customization/overlay specified by `config`. This is
@@ -79,9 +86,10 @@ class NET_EXPORT GlobalFirstPartySets {
       const FirstPartySetsContextConfig& fps_context_config) const;
 
   // Modifies this instance such that it will respect the given
-  // manually-specified set.
+  // manually-specified set. `manual_entries` should contain entries for aliases
+  // as well as "canonical" sites.
   void ApplyManuallySpecifiedSet(
-      const LocalSetDeclaration& local_set_declaration);
+      const base::flat_map<SchemefulSite, FirstPartySetEntry>& manual_entries);
 
   // Directly sets this instance's manual config. This is unsafe, because it
   // assumes that the config was computed by this instance (or one with
@@ -141,8 +149,7 @@ class NET_EXPORT GlobalFirstPartySets {
       base::Version public_sets_version,
       base::flat_map<SchemefulSite, FirstPartySetEntry> entries,
       base::flat_map<SchemefulSite, SchemefulSite> aliases,
-      FirstPartySetsContextConfig manual_config,
-      base::flat_map<SchemefulSite, SchemefulSite> manual_aliases);
+      FirstPartySetsContextConfig manual_config);
 
   // Same as the public version of FindEntry, but is allowed to omit the
   // `config` argument (i.e. pass nullptr instead of a reference).
@@ -166,16 +173,6 @@ class NET_EXPORT GlobalFirstPartySets {
       base::FunctionRef<bool(const SchemefulSite&, const FirstPartySetEntry&)>
           f) const;
 
-  // Iterates over the mappings in `manual_aliases_` and `aliases_` (skipping
-  // entries of `aliases_` that are shadowed), invoking `f` for each `alias,
-  // canonical` pair.
-  void ForEachAlias(base::FunctionRef<void(const SchemefulSite&,
-                                           const SchemefulSite&)> f) const;
-
-  // Returns true iff this instance contains a singleton set (a set with only
-  // one site).
-  bool ContainsSingleton() const;
-
   // The version associated with the component_updater-provided public sets.
   // This may be invalid if the "First-Party Sets" component has not been
   // installed yet, or has been corrupted. Entries and aliases from invalid
@@ -193,10 +190,6 @@ class NET_EXPORT GlobalFirstPartySets {
   // Stores the customizations induced by the manually-specified set. May be
   // empty if no switch was provided.
   FirstPartySetsContextConfig manual_config_;
-
-  // Stores the aliases contained in the manually-specified set. (Note that the
-  // aliases are *also* stored in `manual_config_`.)
-  base::flat_map<SchemefulSite, SchemefulSite> manual_aliases_;
 };
 
 NET_EXPORT std::ostream& operator<<(std::ostream& os,
diff --git a/net/first_party_sets/local_set_declaration.cc b/net/first_party_sets/local_set_declaration.cc
index e86933593a7d471f4100e44dc18d74a5ef4480a0..c37b932c20d204ea074f0cdf5ad1cfabc94a04b3 100644
--- a/net/first_party_sets/local_set_declaration.cc
+++ b/net/first_party_sets/local_set_declaration.cc
@@ -13,16 +13,11 @@ namespace net {
 LocalSetDeclaration::LocalSetDeclaration() = default;
 
 LocalSetDeclaration::LocalSetDeclaration(
-    base::flat_map<SchemefulSite, FirstPartySetEntry> set_entries,
-    base::flat_map<SchemefulSite, SchemefulSite> aliases)
-    : entries_(std::move(set_entries)), aliases_(std::move(aliases)) {
-  // Every alias must map to some canonical site in `entries_`.
-  CHECK(base::ranges::all_of(
-      aliases_, [&](const auto& p) { return entries_.contains(p.second); }));
-
+    base::flat_map<SchemefulSite, FirstPartySetEntry> set_entries)
+    : entries_(std::move(set_entries)) {
   if (!entries_.empty()) {
     // Must not be a singleton set (i.e. must have more than one entry).
-    CHECK_GT(entries_.size() + aliases_.size(), 1u);
+    CHECK_GT(entries_.size(), 1u);
 
     // All provided entries must have the same primary site. I.e., there must
     // only be one set.
diff --git a/net/first_party_sets/local_set_declaration.h b/net/first_party_sets/local_set_declaration.h
index 32814cf5157ba05e91bc87afa466272d24953c8e..6d6ad781ec088112dfe4e537a3587b206cd2b85d 100644
--- a/net/first_party_sets/local_set_declaration.h
+++ b/net/first_party_sets/local_set_declaration.h
@@ -30,8 +30,7 @@ class NET_EXPORT LocalSetDeclaration {
   // the same set (i.e. they must have the same primary site). The set must not
   // be a singleton (i.e. must have more than one entry, or must be empty).
   explicit LocalSetDeclaration(
-      base::flat_map<SchemefulSite, FirstPartySetEntry> set_entries,
-      base::flat_map<SchemefulSite, SchemefulSite> aliases);
+      base::flat_map<SchemefulSite, FirstPartySetEntry> set_entries);
 
   ~LocalSetDeclaration();
 
@@ -48,17 +47,10 @@ class NET_EXPORT LocalSetDeclaration {
     return entries_;
   }
 
-  const base::flat_map<SchemefulSite, SchemefulSite>& aliases() const {
-    return aliases_;
-  }
-
  private:
-  // Stores the set of entries, without ccTLD aliases. This may be empty if no
-  // set was locally defined.
+  // Stores the set of entries and ccTLD aliases. This may be empty if no set
+  // was locally defined.
   base::flat_map<SchemefulSite, FirstPartySetEntry> entries_;
-
-  // Stores the ccTLD aliases. May be empty.
-  base::flat_map<SchemefulSite, SchemefulSite> aliases_;
 };
 
 }  // namespace net
diff --git a/services/network/cookie_manager.cc b/services/network/cookie_manager.cc
index e5e410525d8a6ffe8f653fee3de4be1eaca504a9..7c11eb0558368aa2d94cf4e4f15d5b09f665719e 100644
--- a/services/network/cookie_manager.cc
+++ b/services/network/cookie_manager.cc
@@ -141,8 +141,8 @@ void CookieManager::SetCanonicalCookie(const net::CanonicalCookie& cookie,
         cookie.Name(), cookie.Value(), cookie.Domain(), cookie.Path(),
         cookie.CreationDate(), adjusted_expiry_date, cookie.LastAccessDate(),
         cookie.LastUpdateDate(), cookie.IsSecure(), cookie.IsHttpOnly(),
-        cookie.SameSite(), cookie.Priority(), cookie_partition_key,
-        cookie.SourceScheme(), cookie.SourcePort());
+        cookie.SameSite(), cookie.Priority(), cookie.IsSameParty(),
+        cookie_partition_key, cookie.SourceScheme(), cookie.SourcePort());
     if (!cookie_ptr) {
       std::move(callback).Run(
           net::CookieAccessResult(net::CookieInclusionStatus(
diff --git a/services/network/public/cpp/cookie_manager_mojom_traits.cc b/services/network/public/cpp/cookie_manager_mojom_traits.cc
index bdf07a173b84ab6a4c3222ecbb2da84130950d06..5269c91580bc8d9cf93c3323f7b96ac748cd5972 100644
--- a/services/network/public/cpp/cookie_manager_mojom_traits.cc
+++ b/services/network/public/cpp/cookie_manager_mojom_traits.cc
@@ -692,8 +692,8 @@ bool StructTraits<
       std::move(name), std::move(value), std::move(domain), std::move(path),
       std::move(creation_time), std::move(expiry_time),
       std::move(last_access_time), std::move(last_update_time), cookie.secure(),
-      cookie.httponly(), site_restrictions, priority, partition_key,
-      source_scheme, cookie.source_port());
+      cookie.httponly(), site_restrictions, priority, cookie.same_party(),
+      partition_key, source_scheme, cookie.source_port());
   if (!cc)
     return false;
   *out = *cc;
diff --git a/services/network/public/cpp/cookie_manager_mojom_traits.h b/services/network/public/cpp/cookie_manager_mojom_traits.h
index 3f7d6369a4e107b71f9c20fe5e212a8ea7d45701..5531222e359de032cb45b28e3451b5622a731069 100644
--- a/services/network/public/cpp/cookie_manager_mojom_traits.h
+++ b/services/network/public/cpp/cookie_manager_mojom_traits.h
@@ -270,6 +270,9 @@ struct StructTraits<network::mojom::CanonicalCookieDataView,
   static net::CookieSourceScheme source_scheme(const net::CanonicalCookie& c) {
     return c.SourceScheme();
   }
+  static bool same_party(const net::CanonicalCookie& c) {
+    return c.IsSameParty();
+  }
   static const absl::optional<net::CookiePartitionKey>& partition_key(
       const net::CanonicalCookie& c) {
     return c.PartitionKey();
diff --git a/services/network/public/cpp/first_party_sets_mojom_traits.cc b/services/network/public/cpp/first_party_sets_mojom_traits.cc
index b5d5d26e7d2362ba2a9d17be393cb70cb001b827..0c20fd9b054b6bdf989adde7d9c03f4f784215d9 100644
--- a/services/network/public/cpp/first_party_sets_mojom_traits.cc
+++ b/services/network/public/cpp/first_party_sets_mojom_traits.cc
@@ -127,29 +127,8 @@ bool StructTraits<network::mojom::GlobalFirstPartySetsDataView,
   if (!sets.ReadManualConfig(&manual_config))
     return false;
 
-  base::flat_map<net::SchemefulSite, net::SchemefulSite> manual_aliases;
-  if (!sets.ReadManualAliases(&manual_aliases)) {
-    return false;
-  }
-
-  // The manual_config must contain both the alias overrides and their
-  // corresponding canonical overrides, none of which may be deletions.
-  if (!base::ranges::all_of(manual_aliases, [&](const auto& pair) {
-        absl::optional<net::FirstPartySetEntryOverride> aliased_override =
-            manual_config.FindOverride(pair.first);
-        absl::optional<net::FirstPartySetEntryOverride> canonical_override =
-            manual_config.FindOverride(pair.second);
-        return aliased_override.has_value() &&
-               !aliased_override->IsDeletion() &&
-               canonical_override.has_value() &&
-               !canonical_override->IsDeletion();
-      })) {
-    return false;
-  }
-
-  *out_sets = net::GlobalFirstPartySets(
-      std::move(public_sets_version), std::move(entries), std::move(aliases),
-      std::move(manual_config), std::move(manual_aliases));
+  *out_sets = net::GlobalFirstPartySets(std::move(public_sets_version), entries,
+                                        aliases, std::move(manual_config));
 
   return true;
 }
diff --git a/services/network/public/cpp/first_party_sets_mojom_traits.h b/services/network/public/cpp/first_party_sets_mojom_traits.h
index 8a03b2f3216fdce84c868d71188b8a702b51ad61..b255f56ead022bb237296e7560c73f692a7d7ee3 100644
--- a/services/network/public/cpp/first_party_sets_mojom_traits.h
+++ b/services/network/public/cpp/first_party_sets_mojom_traits.h
@@ -103,11 +103,6 @@ struct COMPONENT_EXPORT(FIRST_PARTY_SETS_MOJOM_TRAITS)
     return sets.manual_config_;
   }
 
-  static const base::flat_map<net::SchemefulSite, net::SchemefulSite>&
-  manual_aliases(const net::GlobalFirstPartySets& sets) {
-    return sets.manual_aliases_;
-  }
-
   static bool Read(network::mojom::GlobalFirstPartySetsDataView sets,
                    net::GlobalFirstPartySets* out_sets);
 };
diff --git a/services/network/public/mojom/cookie_manager.mojom b/services/network/public/mojom/cookie_manager.mojom
index de434341bd6328f5876fb8057d652582dbbf4802..6f628024cbe845238c22aa57cd42677ffdf76365 100644
--- a/services/network/public/mojom/cookie_manager.mojom
+++ b/services/network/public/mojom/cookie_manager.mojom
@@ -184,6 +184,7 @@ struct CanonicalCookie {
   CookieSameSite site_restrictions = NO_RESTRICTION;
   CookiePriority priority = MEDIUM;
   CookieSourceScheme source_scheme = kUnset;
+  bool same_party = false;
   CookiePartitionKey? partition_key;
   // -1 because of url::PORT_UNSPECIFIED
   // url/third_party/mozilla/url_parse.h
diff --git a/services/network/public/mojom/first_party_sets.mojom b/services/network/public/mojom/first_party_sets.mojom
index 875138dee43ec8739c35fbab27e27ca0fc502e69..0ea745cd2450c2d92002c3a0113295b0d4bbd40e 100644
--- a/services/network/public/mojom/first_party_sets.mojom
+++ b/services/network/public/mojom/first_party_sets.mojom
@@ -83,11 +83,7 @@ struct GlobalFirstPartySets {
   // The mapping from site alias to canonical site from public sets.
   map<SchemefulSite, SchemefulSite> aliases;
 
-  // The config induced by the manually-supplied set. This config contains all
-  // relevant ccTLD aliases.
+  // The config induced by the manually-supplied set.
   FirstPartySetsContextConfig manual_config;
-
-  // The aliases contained in the manually-supplied set.
-  map<SchemefulSite, SchemefulSite> manual_aliases;
 };
 
diff --git a/services/network/public/mojom/network_context.mojom b/services/network/public/mojom/network_context.mojom
index e6c2bb7599d1606725c982db98255a04ed456419..1de4e2666492196bb5dcd5a45632fe0928cc0a82 100644
--- a/services/network/public/mojom/network_context.mojom
+++ b/services/network/public/mojom/network_context.mojom
@@ -1013,7 +1013,7 @@ interface NetworkContext {
   // document's frame)), or a request origin when |role| is
   // RestrictedCookieManagerRole::NETWORK (a network request).
   //
-  // |isolation_info| contains info for SameSite cookie queries.
+  // |isolation_info| contains info for SameSite and SameParty cookie queries.
   // Must be fully populated.
   //
   // If |role| == SCRIPT, this interface can be safely handed out to a process
diff --git a/services/network/restricted_cookie_manager.cc b/services/network/restricted_cookie_manager.cc
index b5b48a0ce69c7bbe7ce61028fc5d832875e59b7c..476a38457a05ed8c83fbb996756af422ad4b72b7 100644
--- a/services/network/restricted_cookie_manager.cc
+++ b/services/network/restricted_cookie_manager.cc
@@ -855,8 +855,8 @@ void RestrictedCookieManager::SetCanonicalCookie(
       net::CanonicalCookie::FromStorage(
           cookie.Name(), cookie.Value(), cookie.Domain(), cookie.Path(), now,
           cookie.ExpiryDate(), now, now, cookie.IsSecure(), cookie.IsHttpOnly(),
-          cookie.SameSite(), cookie.Priority(), cookie_partition_key,
-          source_scheme, origin_.port());
+          cookie.SameSite(), cookie.Priority(), cookie.IsSameParty(),
+          cookie_partition_key, source_scheme, origin_.port());
   DCHECK(sanitized_cookie);
   // FromStorage() uses a less strict version of IsCanonical(), we need to check
   // the stricter version as well here.
diff --git a/third_party/blink/public/devtools_protocol/browser_protocol.pdl b/third_party/blink/public/devtools_protocol/browser_protocol.pdl
index 5c830ad4623ccb59d71d3f842e45927140597a95..025d11f055ac609a3889050b08aa0881a55933f2 100644
--- a/third_party/blink/public/devtools_protocol/browser_protocol.pdl
+++ b/third_party/blink/public/devtools_protocol/browser_protocol.pdl
@@ -5858,7 +5858,7 @@ domain Network
       # Cookie Priority
       experimental CookiePriority priority
       # True if cookie is SameParty.
-      experimental deprecated boolean sameParty
+      experimental boolean sameParty
       # Cookie source scheme type.
       experimental CookieSourceScheme sourceScheme
       # Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
diff --git a/third_party/blink/renderer/modules/cookie_store/cookie_store.cc b/third_party/blink/renderer/modules/cookie_store/cookie_store.cc
index ba3ed0252770c90b83721752356d3e1146fcd9f5..47c4b4022517bd2b147b18e999159a10790dcfc2 100644
--- a/third_party/blink/renderer/modules/cookie_store/cookie_store.cc
+++ b/third_party/blink/renderer/modules/cookie_store/cookie_store.cc
@@ -167,7 +167,7 @@ std::unique_ptr<net::CanonicalCookie> ToCanonicalCookie(
           path.Utf8(), base::Time() /*creation*/, expires,
           base::Time() /*last_access*/, true /*secure*/, false /*http_only*/,
           same_site, net::CookiePriority::COOKIE_PRIORITY_DEFAULT,
-          cookie_partition_key, &status_out);
+          /*same_party=*/false, cookie_partition_key, &status_out);
 
   // TODO(crbug.com/1310444): Improve serialization validation comments and
   // associate them with ExceptionState codes.
