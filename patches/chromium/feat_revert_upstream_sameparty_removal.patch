From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Keeley Hammond <khammond@slack-corp.com>
Date: Tue, 27 Feb 2024 22:34:57 -0800
Subject: feat: revert upstream SameParty removal

This patch removes the SameParty removal by Chrome,
to make future Electron versions compatible with
SameParty.

Revert "[RWS] Rewrite FPSParser to return net::GlobalFirstPartySets" | This reverts commit 3d65d32b9dbfa822c8883a11ea7b3f1cb3aacd00.
Revert "[RWS] Remove enum from parser's public API" | This reverts commit e0404fe08b2823ca2546bd2665e986595ebf43b2.
5146347: [RWS] Introduce a wrapper type to hold RWSOverrides policy data | https://chromium-review.googlesource.com/c/chromium/src/+/5146347
Revert "[RWS] Introduce SetsMutation type to uphold invariants" | This reverts commit 7d1bad4a311e8532a56e65eb68557f51e7c1c35e.
Revert "[RWS] Store local-set-aliases separately; detect shadowing properly" | This reverts commit d4176432c1cf25b3eb6de159ec3aa0e9a1c1eec0.
Revert "[RWS] Rewrite LocalSetDeclaration ctor to accept aliases separately" | This reverts commit 60fa94a5216486f0a64550661db375c909a710d4.
Revert "[RWS] Move switch-parsing code to FPSParser; move LocalSetDecl to net/" | This reverts commit bd490b71bd1ce505f0ec9f1749ae4d1079e008b7.
Revert "[RWS] Remove CanonicalCookie::IsSameParty method" | This reverts commit 009417ac633095bcd3d0b8eca6b00b5189c1ca1f.

diff --git a/content/app/content_main_runner_impl.cc b/content/app/content_main_runner_impl.cc
index 48f1cdd0a7763242b81c7a54cad72700c8a42af1..f971be672f7e975d9ca173c579345e7dc3382661 100644
--- a/content/app/content_main_runner_impl.cc
+++ b/content/app/content_main_runner_impl.cc
@@ -61,6 +61,7 @@
 #include "content/browser/browser_process_io_thread.h"
 #include "content/browser/browser_thread_impl.h"
 #include "content/browser/first_party_sets/first_party_sets_handler_impl.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/browser/gpu/gpu_main_thread_factory.h"
 #include "content/browser/renderer_host/render_process_host_impl.h"
 #include "content/browser/scheduler/browser_task_executor.h"
@@ -104,7 +105,6 @@
 #include "mojo/public/cpp/system/dynamic_library_support.h"
 #include "mojo/public/cpp/system/invitation.h"
 #include "mojo/public/cpp/system/message_pipe.h"
-#include "net/first_party_sets/local_set_declaration.h"
 #include "ppapi/buildflags/buildflags.h"
 #include "sandbox/policy/sandbox.h"
 #include "sandbox/policy/sandbox_type.h"
@@ -1259,7 +1259,7 @@ int ContentMainRunnerImpl::RunBrowser(MainFunctionParams main_params,
       // Minimal browser mode doesn't initialize First-Party Sets the "usual"
       // way, so we do it manually.
       content::FirstPartySetsHandlerImpl::GetInstance()->Init(
-          base::FilePath(), net::LocalSetDeclaration());
+          base::FilePath(), LocalSetDeclaration());
     }
 
     discardable_shared_memory_manager_ =
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 143c98e3294fb07b08c1d8e97013034f8453e074..60afe83542bae8e45a66946044db2e573f934e4b 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -1030,6 +1030,8 @@ source_set("browser") {
     "first_party_sets/first_party_sets_overrides_policy.h",
     "first_party_sets/first_party_sets_site_data_remover.cc",
     "first_party_sets/first_party_sets_site_data_remover.h",
+    "first_party_sets/local_set_declaration.cc",
+    "first_party_sets/local_set_declaration.h",
     "font_access/font_access_manager.cc",
     "font_access/font_access_manager.h",
     "font_access/font_enumeration_cache.cc",
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index 8c144725c6e54172d01b90e1d1196679a53f4b78..6f3661179225e322b2343e6ff4600073966a682d 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -70,8 +70,8 @@
 #include "content/browser/compositor/viz_process_transport_factory.h"
 #include "content/browser/download/save_file_manager.h"
 #include "content/browser/field_trial_synchronizer.h"
-#include "content/browser/first_party_sets/first_party_set_parser.h"
 #include "content/browser/first_party_sets/first_party_sets_handler_impl.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/browser/gpu/browser_gpu_channel_host_factory.h"
 #include "content/browser/gpu/browser_gpu_client_delegate.h"
 #include "content/browser/gpu/compositor_util.h"
@@ -1009,8 +1009,7 @@ int BrowserMainLoop::PreMainMessageLoopRun() {
   if (result_code_ == RESULT_CODE_NORMAL_EXIT) {
     FirstPartySetsHandlerImpl::GetInstance()->Init(
         GetContentClient()->browser()->GetFirstPartySetsDirectory(),
-        FirstPartySetParser::ParseFromCommandLine(
-            GetRelatedWebsiteSetSwitch()));
+        LocalSetDeclaration(GetRelatedWebsiteSetSwitch()));
   }
 
   variations::MaybeScheduleFakeCrash();
diff --git a/content/browser/devtools/protocol/network_handler.cc b/content/browser/devtools/protocol/network_handler.cc
index 2bbc46fd4748246b7fa3e6a8cfe38b43684bf8d7..dfc8de25fa4039c9ceead36c6fd8d64e9974f802 100644
--- a/content/browser/devtools/protocol/network_handler.cc
+++ b/content/browser/devtools/protocol/network_handler.cc
@@ -186,7 +186,7 @@ std::unique_ptr<Network::Cookie> BuildCookie(
           .SetSecure(cookie.IsSecure())
           .SetSession(!cookie.IsPersistent())
           .SetPriority(BuildCookiePriority(cookie.Priority()))
-          .SetSameParty(false)
+          .SetSameParty(cookie.IsSameParty())
           .SetSourceScheme(BuildCookieSourceScheme(cookie.SourceScheme()))
           .SetSourcePort(cookie.SourcePort())
           .Build();
diff --git a/content/browser/first_party_sets/first_party_set_parser.cc b/content/browser/first_party_sets/first_party_set_parser.cc
index 5465b7801280a76017e4cb0552d01a4d179b7dc7..af422c4a8c7221048c5f061344ffbfc71b8f548d 100644
--- a/content/browser/first_party_sets/first_party_set_parser.cc
+++ b/content/browser/first_party_sets/first_party_set_parser.cc
@@ -29,9 +29,7 @@
 #include "net/base/registry_controlled_domains/registry_controlled_domain.h"
 #include "net/base/schemeful_site.h"
 #include "net/first_party_sets/first_party_set_entry.h"
-#include "net/first_party_sets/global_first_party_sets.h"
-#include "net/first_party_sets/local_set_declaration.h"
-#include "net/first_party_sets/sets_mutation.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 #include "url/gurl.h"
 #include "url/origin.h"
 
@@ -43,10 +41,9 @@ using ParseErrorType = FirstPartySetsHandler::ParseErrorType;
 using ParseWarningType = FirstPartySetsHandler::ParseWarningType;
 using ParseError = FirstPartySetsHandler::ParseError;
 using ParseWarning = FirstPartySetsHandler::ParseWarning;
-using SetsMap = base::flat_map<net::SchemefulSite, net::FirstPartySetEntry>;
-using Aliases = base::flat_map<net::SchemefulSite, net::SchemefulSite>;
-using SetsAndAliases = std::pair<SetsMap, Aliases>;
-using SingleSet = base::flat_map<net::SchemefulSite, net::FirstPartySetEntry>;
+using Aliases = FirstPartySetParser::Aliases;
+using SetsAndAliases = FirstPartySetParser::SetsAndAliases;
+using SetsMap = FirstPartySetParser::SetsMap;
 
 constexpr char kFirstPartySetPrimaryField[] = "primary";
 constexpr char kFirstPartySetAssociatedSitesField[] = "associatedSites";
@@ -57,13 +54,11 @@ constexpr char kFirstPartySetPolicyAdditionsField[] = "additions";
 
 constexpr int kFirstPartySetsMaxAssociatedSites = 5;
 
-enum class PolicySetType { kReplacement, kAddition };
-
-const char* SetTypeToString(PolicySetType set_type) {
+const char* SetTypeToString(FirstPartySetParser::PolicySetType set_type) {
   switch (set_type) {
-    case PolicySetType::kReplacement:
+    case FirstPartySetParser::PolicySetType::kReplacement:
       return kFirstPartySetPolicyReplacementsField;
-    case PolicySetType::kAddition:
+    case FirstPartySetParser::PolicySetType::kAddition:
       return kFirstPartySetPolicyAdditionsField;
   }
 }
@@ -154,11 +149,6 @@ std::optional<std::string> RemoveTldFromSite(const net::SchemefulSite& site) {
   return serialized.substr(0, serialized.size() - tld_length);
 }
 
-struct ParsedPolicySetLists {
-  std::vector<SingleSet> replacements;
-  std::vector<SingleSet> additions;
-};
-
 class ParseContext {
  public:
   ParseContext(bool emit_errors, bool exempt_from_limits)
@@ -273,18 +263,18 @@ class ParseContext {
                                          {kFirstPartySetAssociatedSitesField}));
     }
 
-    return std::make_pair(SingleSet(set_entries), aliases);
+    return std::make_pair(FirstPartySetParser::SingleSet(set_entries), aliases);
   }
 
   // Returns the parsed sets if successful; otherwise returns the first error.
-  base::expected<std::vector<SingleSet>, ParseError> GetPolicySetsFromList(
-      const base::Value::List* policy_sets,
-      PolicySetType set_type) {
+  base::expected<std::vector<FirstPartySetParser::SingleSet>, ParseError>
+  GetPolicySetsFromList(const base::Value::List* policy_sets,
+                        FirstPartySetParser::PolicySetType set_type) {
     if (!policy_sets) {
       return {};
     }
 
-    std::vector<SingleSet> parsed_sets;
+    std::vector<FirstPartySetParser::SingleSet> parsed_sets;
     size_t previous_size = warnings_.size();
     for (int i = 0; i < static_cast<int>(policy_sets->size()); i++) {
       base::expected<SetsAndAliases, ParseError> parsed =
@@ -339,20 +329,13 @@ class ParseContext {
   // Removes invalid site entries and aliases, and fixes up any lingering
   // singletons. Modifies the data in-place.
   void PostProcessSets(std::vector<SetsMap::value_type>& sets,
-                       std::vector<Aliases::value_type>& aliases) {
+                       std::vector<Aliases::value_type>& aliases) const {
     if (invalid_keys_.empty()) {
       return;
     }
 
     base::flat_set<net::SchemefulSite> possible_singletons;
 
-    // Erase invalid members/primaries, and collect primary sites that might
-    // become singletons.
-    base::EraseIf(
-        sets,
-        [&](const std::pair<net::SchemefulSite, net::FirstPartySetEntry>& pair)
-            -> bool { return IsInvalidEntry(pair, &possible_singletons); });
-
     // Erase invalid aliases, and collect canonical sites that are primaries and
     // might become singletons.
     base::EraseIf(
@@ -362,6 +345,13 @@ class ParseContext {
           return IsInvalidAlias(pair, possible_singletons, sets);
         });
 
+    // Erase invalid members/primaries, and collect primary sites that might
+    // become singletons.
+    base::EraseIf(
+        sets,
+        [&](const std::pair<net::SchemefulSite, net::FirstPartySetEntry>& pair)
+            -> bool { return IsInvalidEntry(pair, &possible_singletons); });
+
     if (possible_singletons.empty()) {
       return;
     }
@@ -399,13 +389,13 @@ class ParseContext {
   // Removes invalid site entries and fixes up any lingering singletons.
   // Modifies the lists in-place.
   void PostProcessSetLists(
-      base::expected<ParsedPolicySetLists, FirstPartySetsHandler::ParseError>&
-          lists_or_error) {
+      base::expected<FirstPartySetParser::ParsedPolicySetLists,
+                     FirstPartySetsHandler::ParseError>& lists_or_error) const {
     if (!lists_or_error.has_value() || invalid_keys_.empty()) {
       return;
     }
 
-    ParsedPolicySetLists& lists = lists_or_error.value();
+    FirstPartySetParser::ParsedPolicySetLists& lists = lists_or_error.value();
 
     // Erase invalid members/primaries.
     const auto is_invalid_entry =
@@ -422,7 +412,7 @@ class ParseContext {
 
     // Since we just removed some keys, we have to double-check that there are
     // no singleton sets.
-    const auto is_singleton = [](const SingleSet& set) {
+    const auto is_singleton = [](const FirstPartySetParser::SingleSet& set) {
       return set.size() <= 1;
     };
     base::EraseIf(lists.additions, is_singleton);
@@ -604,27 +594,20 @@ class ParseContext {
   // set.
   bool IsInvalidEntry(
       const std::pair<net::SchemefulSite, net::FirstPartySetEntry> pair,
-      base::flat_set<net::SchemefulSite>* possible_singletons) {
+      base::flat_set<net::SchemefulSite>* possible_singletons) const {
     const net::SchemefulSite& key = pair.first;
     const net::FirstPartySetEntry& entry = pair.second;
     return base::ranges::any_of(
         invalid_keys_, [&](const net::SchemefulSite& invalid_key) -> bool {
-          if (invalid_key == entry.primary()) {
-            // The primary is invalid, so we have to kill the whole set. So this
-            // non-primary site must also be considered invalid in the future.
-            invalid_keys_.insert(pair.first);
-            return true;
-          }
-          if (invalid_key == key) {
+          const bool key_matches = invalid_key == key;
+          const bool primary_matches = invalid_key == entry.primary();
+          if (key_matches && !primary_matches && possible_singletons) {
             // This is a member whose primary might end up being a
             // singleton, since it's losing at least one member (and it
             // itself isn't invalid).
-            if (possible_singletons) {
-              possible_singletons->insert(entry.primary());
-            }
-            return true;
+            possible_singletons->insert(entry.primary());
           }
-          return false;
+          return key_matches || primary_matches;
         });
   }
 
@@ -673,9 +656,43 @@ class ParseContext {
   mutable base::flat_set<SetsMap::key_type> invalid_keys_;
 };
 
-SetsAndAliases ParseSetsFromStreamInternal(std::istream& input,
-                                           bool emit_errors,
-                                           bool emit_metrics) {
+}  // namespace
+
+FirstPartySetParser::ParsedPolicySetLists::ParsedPolicySetLists(
+    std::vector<FirstPartySetParser::SingleSet> replacement_list,
+    std::vector<FirstPartySetParser::SingleSet> addition_list)
+    : replacements(std::move(replacement_list)),
+      additions(std::move(addition_list)) {}
+
+FirstPartySetParser::ParsedPolicySetLists::ParsedPolicySetLists() = default;
+FirstPartySetParser::ParsedPolicySetLists::ParsedPolicySetLists(
+    FirstPartySetParser::ParsedPolicySetLists&&) = default;
+FirstPartySetParser::ParsedPolicySetLists::ParsedPolicySetLists(
+    const FirstPartySetParser::ParsedPolicySetLists&) = default;
+FirstPartySetParser::ParsedPolicySetLists::~ParsedPolicySetLists() = default;
+
+bool FirstPartySetParser::ParsedPolicySetLists::operator==(
+    const FirstPartySetParser::ParsedPolicySetLists& other) const {
+  return std::tie(replacements, additions) ==
+         std::tie(other.replacements, other.additions);
+}
+
+absl::optional<net::SchemefulSite>
+FirstPartySetParser::CanonicalizeRegisteredDomain(
+    const base::StringPiece origin_string,
+    bool emit_errors) {
+  ValidateSiteResult result =
+      ParseContext(emit_errors, /*exempt_from_limits=*/false)
+          .Canonicalize(origin_string);
+  if (result.has_error()) {
+    return absl::nullopt;
+  }
+  return result.site();
+}
+
+SetsAndAliases FirstPartySetParser::ParseSetsFromStream(std::istream& input,
+                                                        bool emit_errors,
+                                                        bool emit_metrics) {
   std::vector<SetsMap::value_type> sets;
   std::vector<Aliases::value_type> aliases;
   ParseContext context(emit_errors, /*exempt_from_limits=*/false);
@@ -728,35 +745,7 @@ SetsAndAliases ParseSetsFromStreamInternal(std::istream& input,
     base::UmaHistogramCounts1000(
         "Cookie.FirstPartySets.ComponentSetsNonfatalErrors", nonfatal_errors);
   }
-
-  return std::make_pair(std::move(sets), std::move(aliases));
-}
-
-}  // namespace
-
-std::optional<net::SchemefulSite>
-FirstPartySetParser::CanonicalizeRegisteredDomain(
-    const base::StringPiece origin_string,
-    bool emit_errors) {
-  ValidateSiteResult result =
-      ParseContext(emit_errors, /*exempt_from_limits=*/false)
-          .Canonicalize(origin_string);
-  if (result.has_error()) {
-    return std::nullopt;
-  }
-  return result.site();
-}
-
-net::GlobalFirstPartySets FirstPartySetParser::ParseSetsFromStream(
-    std::istream& input,
-    base::Version version,
-    bool emit_errors,
-    bool emit_metrics) {
-  SetsAndAliases sets_and_aliases =
-      ParseSetsFromStreamInternal(input, emit_errors, emit_metrics);
-  return net::GlobalFirstPartySets(std::move(version),
-                                   std::move(sets_and_aliases.first),
-                                   std::move(sets_and_aliases.second));
+  return std::make_pair(sets, aliases);
 }
 
 FirstPartySetParser::PolicyParseResult
@@ -778,43 +767,27 @@ FirstPartySetParser::ParseSetsFromEnterprisePolicy(
 
   context.PostProcessSetLists(set_lists);
 
-  return FirstPartySetParser::PolicyParseResult(
-      std::move(set_lists).transform([](ParsedPolicySetLists lists) {
-        return FirstPartySetsOverridesPolicy(net::SetsMutation(
-            std::move(lists.replacements), std::move(lists.additions)));
-      }),
-      context.warnings());
+  return FirstPartySetParser::PolicyParseResult(std::move(set_lists),
+                                                context.warnings());
 }
 
-// static
-net::LocalSetDeclaration FirstPartySetParser::ParseFromCommandLine(
-    const std::string& switch_value) {
-  std::istringstream stream(switch_value);
-
-  SetsAndAliases parsed =
-      ParseSetsFromStreamInternal(stream, /*emit_errors=*/true,
-                                  /*emit_metrics*/ false);
-
-  SetsMap entries = std::move(parsed.first);
-  Aliases aliases = std::move(parsed.second);
-
-  if (entries.empty()) {
-    return net::LocalSetDeclaration();
+std::ostream& operator<<(
+    std::ostream& os,
+    const FirstPartySetParser::ParsedPolicySetLists& lists) {
+  os << "additions: {";
+  for (const auto& set : lists.additions) {
+    for (const auto& pair : set) {
+      os << pair.first << " -> " << pair.second << ", ";
+    }
   }
-
-  const net::SchemefulSite& primary = entries.begin()->second.primary();
-
-  if (base::ranges::any_of(entries,
-                           [&primary](const SetsMap::value_type& pair) {
-                             return pair.second.primary() != primary;
-                           })) {
-    // More than one set was provided. That is (currently) unsupported.
-    LOG(ERROR) << "Ignoring use-related-website-set switch due to multiple set "
-                  "declarations.";
-    return net::LocalSetDeclaration();
+  os << "}, replacements: {";
+  for (const auto& set : lists.replacements) {
+    for (const auto& pair : set) {
+      os << pair.first << " -> " << pair.second << ", ";
+    }
   }
-
-  return net::LocalSetDeclaration(std::move(entries), std::move(aliases));
+  os << "}";
+  return os;
 }
 
 }  // namespace content
diff --git a/content/browser/first_party_sets/first_party_set_parser.h b/content/browser/first_party_sets/first_party_set_parser.h
index 47c07a209a9afafc696f3aabbef97422727f5195..d91cd5d119b1da6247d04bb28dd8c529c65deb85 100644
--- a/content/browser/first_party_sets/first_party_set_parser.h
+++ b/content/browser/first_party_sets/first_party_set_parser.h
@@ -18,18 +18,39 @@
 #include "content/public/browser/first_party_sets_handler.h"
 #include "net/base/schemeful_site.h"
 #include "net/first_party_sets/first_party_set_entry.h"
-#include "net/first_party_sets/global_first_party_sets.h"
-#include "net/first_party_sets/local_set_declaration.h"
-#include "net/first_party_sets/sets_mutation.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace content {
 
 class CONTENT_EXPORT FirstPartySetParser {
  public:
-  using PolicyParseResult =
-      std::pair<base::expected<FirstPartySetsOverridesPolicy,
-                               FirstPartySetsHandler::ParseError>,
-                std::vector<FirstPartySetsHandler::ParseWarning>>;
+  using SetsMap = base::flat_map<net::SchemefulSite, net::FirstPartySetEntry>;
+  // Keys are alias sites, values are their canonical representatives.
+  using Aliases = base::flat_map<net::SchemefulSite, net::SchemefulSite>;
+  using SingleSet = SetsMap;
+  using SetsAndAliases = std::pair<SetsMap, Aliases>;
+  enum class PolicySetType { kReplacement, kAddition };
+
+  struct CONTENT_EXPORT ParsedPolicySetLists {
+    ParsedPolicySetLists(std::vector<SingleSet> replacement_list,
+                         std::vector<SingleSet> addition_list);
+
+    ParsedPolicySetLists();
+    ParsedPolicySetLists(ParsedPolicySetLists&&);
+    ParsedPolicySetLists& operator=(ParsedPolicySetLists&&) = default;
+    ParsedPolicySetLists(const ParsedPolicySetLists&);
+    ParsedPolicySetLists& operator=(const ParsedPolicySetLists&) = default;
+    ~ParsedPolicySetLists();
+
+    bool operator==(const ParsedPolicySetLists& other) const;
+
+    std::vector<SingleSet> replacements;
+    std::vector<SingleSet> additions;
+  };
+
+  using PolicyParseResult = std::pair<
+      base::expected<ParsedPolicySetLists, FirstPartySetsHandler::ParseError>,
+      std::vector<FirstPartySetsHandler::ParseWarning>>;
 
   FirstPartySetParser() = delete;
   ~FirstPartySetParser() = delete;
@@ -43,12 +64,11 @@ class CONTENT_EXPORT FirstPartySetParser {
   // not check versions or assertions, since it is intended only for sets
   // received by Component Updater.
   //
-  // Returns an empty GlobalFirstPartySets instance if parsing or validation of
-  // any set failed.
-  static net::GlobalFirstPartySets ParseSetsFromStream(std::istream& input,
-                                                       base::Version version,
-                                                       bool emit_errors,
-                                                       bool emit_metrics);
+  // Returns an empty map if parsing or validation of any set failed. Must not
+  // be called before field trial state has been initialized.
+  static SetsAndAliases ParseSetsFromStream(std::istream& input,
+                                            bool emit_errors,
+                                            bool emit_metrics);
 
   // Canonicalizes the passed in origin to a registered domain. In particular,
   // this ensures that the origin is non-opaque, is HTTPS, and has a registered
@@ -64,11 +84,12 @@ class CONTENT_EXPORT FirstPartySetParser {
   // returns an error.
   [[nodiscard]] static PolicyParseResult ParseSetsFromEnterprisePolicy(
       const base::Value::Dict& policy);
-
-  [[nodiscard]] static net::LocalSetDeclaration ParseFromCommandLine(
-      const std::string& switch_value);
 };
 
+CONTENT_EXPORT std::ostream& operator<<(
+    std::ostream& os,
+    const FirstPartySetParser::ParsedPolicySetLists& lists);
+
 }  // namespace content
 
 #endif  // CONTENT_BROWSER_FIRST_PARTY_SETS_FIRST_PARTY_SET_PARSER_H_
diff --git a/content/browser/first_party_sets/first_party_sets_handler_impl.h b/content/browser/first_party_sets/first_party_sets_handler_impl.h
index b183d8841eda1fa05ecaf01f63d88fb4e6e7689d..7ab1e87244746b03e420290c254cd1ab8aa9295c 100644
--- a/content/browser/first_party_sets/first_party_sets_handler_impl.h
+++ b/content/browser/first_party_sets/first_party_sets_handler_impl.h
@@ -9,10 +9,12 @@
 
 #include "base/files/file_path.h"
 #include "base/functional/callback.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/first_party_sets_handler.h"
 #include "net/first_party_sets/global_first_party_sets.h"
 #include "net/first_party_sets/local_set_declaration.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace content {
 
@@ -35,7 +37,7 @@ class CONTENT_EXPORT FirstPartySetsHandlerImpl : public FirstPartySetsHandler {
   //
   // Only the first call has any effect.
   void virtual Init(const base::FilePath& user_data_dir,
-                    const net::LocalSetDeclaration& local_set) = 0;
+                    const LocalSetDeclaration& local_set) = 0;
 
   // Returns the fully-parsed and validated global First-Party Sets data.
   // Returns the data synchronously via an std::optional if it's already
diff --git a/content/browser/first_party_sets/first_party_sets_handler_impl_instance.cc b/content/browser/first_party_sets/first_party_sets_handler_impl_instance.cc
index 267e0786e139a7a1fc142b6fd1a92e3a5e8c716a..a44fb947444d86c42a016b8141d56d2def67fcf0 100644
--- a/content/browser/first_party_sets/first_party_sets_handler_impl_instance.cc
+++ b/content/browser/first_party_sets/first_party_sets_handler_impl_instance.cc
@@ -13,7 +13,6 @@
 #include "base/functional/bind.h"
 #include "base/logging.h"
 #include "base/metrics/histogram_functions.h"
-#include "base/sequence_checker.h"
 #include "base/task/task_traits.h"
 #include "base/task/thread_pool.h"
 #include "base/types/expected.h"
@@ -24,6 +23,7 @@
 #include "content/browser/first_party_sets/first_party_sets_loader.h"
 #include "content/browser/first_party_sets/first_party_sets_overrides_policy.h"
 #include "content/browser/first_party_sets/first_party_sets_site_data_remover.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/public/browser/browser_context.h"
 #include "content/public/browser/content_browser_client.h"
 #include "content/public/browser/first_party_sets_handler.h"
@@ -32,8 +32,7 @@
 #include "net/first_party_sets/first_party_set_metadata.h"
 #include "net/first_party_sets/first_party_sets_context_config.h"
 #include "net/first_party_sets/global_first_party_sets.h"
-#include "net/first_party_sets/local_set_declaration.h"
-#include "net/first_party_sets/sets_mutation.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace net {
 class SchemefulSite;
@@ -192,7 +191,7 @@ FirstPartySetsHandlerImplInstance::GetSets(
 
 void FirstPartySetsHandlerImplInstance::Init(
     const base::FilePath& user_data_dir,
-    const net::LocalSetDeclaration& local_set) {
+    const LocalSetDeclaration& local_set) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   if (initialized_) {
     return;
@@ -529,12 +528,12 @@ FirstPartySetsHandlerImplInstance::GetContextConfigForPolicyInternal(
   auto [parsed, warnings] =
       FirstPartySetParser::ParseSetsFromEnterprisePolicy(policy);
 
-  if (!parsed.has_value()) {
-    return global_sets_->ComputeConfig(net::SetsMutation());
-  }
-
-  FirstPartySetsOverridesPolicy& policy_result = parsed.value();
-  return global_sets_->ComputeConfig(std::move(policy_result.mutation()));
+  return parsed.has_value()
+             ? global_sets_.value().ComputeConfig(
+                   /*replacement_sets=*/parsed.value().replacements,
+                   /*addition_sets=*/
+                   parsed.value().additions)
+             : net::FirstPartySetsContextConfig();
 }
 
 bool FirstPartySetsHandlerImplInstance::ForEachEffectiveSetEntry(
diff --git a/content/browser/first_party_sets/first_party_sets_handler_impl_instance.h b/content/browser/first_party_sets/first_party_sets_handler_impl_instance.h
index 974da5d2b26053e5624a5a9aa6cee183692b7863..f5b96707c51af8a8ac9d190cf8b0883c7dc213ca 100644
--- a/content/browser/first_party_sets/first_party_sets_handler_impl_instance.h
+++ b/content/browser/first_party_sets/first_party_sets_handler_impl_instance.h
@@ -23,11 +23,13 @@
 #include "content/browser/first_party_sets/first_party_sets_handler_database_helper.h"
 #include "content/browser/first_party_sets/first_party_sets_handler_impl.h"
 #include "content/browser/first_party_sets/first_party_sets_loader.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/common/content_export.h"
 #include "net/first_party_sets/first_party_sets_cache_filter.h"
 #include "net/first_party_sets/first_party_sets_context_config.h"
 #include "net/first_party_sets/global_first_party_sets.h"
 #include "net/first_party_sets/local_set_declaration.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace net {
 class FirstPartySetEntry;
@@ -62,8 +64,8 @@ class CONTENT_EXPORT FirstPartySetsHandlerImplInstance
 
   // FirstPartySetsHandlerImpl:
   void Init(const base::FilePath& user_data_dir,
-            const net::LocalSetDeclaration& local_set) override;
-  [[nodiscard]] std::optional<net::GlobalFirstPartySets> GetSets(
+            const LocalSetDeclaration& local_set) override;
+  [[nodiscard]] absl::optional<net::GlobalFirstPartySets> GetSets(
       base::OnceCallback<void(net::GlobalFirstPartySets)> callback) override;
 
   // FirstPartySetsHandler:
diff --git a/content/browser/first_party_sets/first_party_sets_loader.cc b/content/browser/first_party_sets/first_party_sets_loader.cc
index 21371a4962adf787595b6acba0d4656db563ae52..340f486495e043849754e6429b1065c50b498fce 100644
--- a/content/browser/first_party_sets/first_party_sets_loader.cc
+++ b/content/browser/first_party_sets/first_party_sets_loader.cc
@@ -5,8 +5,11 @@
 #include "content/browser/first_party_sets/first_party_sets_loader.h"
 
 #include <optional>
+#include <iterator>
+#include <set>
 #include <sstream>
 #include <utility>
+#include <vector>
 
 #include "base/containers/flat_map.h"
 #include "base/files/file_util.h"
@@ -15,8 +18,10 @@
 #include "base/task/thread_pool.h"
 #include "base/version.h"
 #include "content/browser/first_party_sets/first_party_set_parser.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "net/first_party_sets/global_first_party_sets.h"
 #include "net/first_party_sets/local_set_declaration.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace content {
 
@@ -39,7 +44,7 @@ FirstPartySetsLoader::~FirstPartySetsLoader() {
 }
 
 void FirstPartySetsLoader::SetManuallySpecifiedSet(
-    const net::LocalSetDeclaration& local_set) {
+    const LocalSetDeclaration& local_set) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
   if (manually_specified_set_.has_value()) {
     return;
@@ -96,9 +101,12 @@ void FirstPartySetsLoader::OnReadSetsFile(base::Version version,
   DCHECK_EQ(component_sets_parse_progress_, Progress::kStarted);
 
   std::istringstream stream(raw_sets);
-  sets_ = FirstPartySetParser::ParseSetsFromStream(stream, std::move(version),
-                                                   /*emit_errors=*/false,
-                                                   /*emit_metrics=*/true);
+  FirstPartySetParser::SetsAndAliases public_sets =
+      FirstPartySetParser::ParseSetsFromStream(stream, /*emit_errors=*/false,
+                                               /*emit_metrics=*/true);
+  sets_ = net::GlobalFirstPartySets(std::move(version),
+                                    std::move(public_sets.first),
+                                    std::move(public_sets.second));
 
   component_sets_parse_progress_ = Progress::kFinished;
   UmaHistogramTimes(
@@ -113,7 +121,9 @@ void FirstPartySetsLoader::MaybeFinishLoading() {
       !manually_specified_set_.has_value()) {
     return;
   }
-  sets_->ApplyManuallySpecifiedSet(manually_specified_set_.value());
+  if (!manually_specified_set_->empty()) {
+    sets_->ApplyManuallySpecifiedSet(manually_specified_set_->GetSet());
+  }
   std::move(on_load_complete_).Run(std::move(sets_).value());
 }
 
diff --git a/content/browser/first_party_sets/first_party_sets_loader.h b/content/browser/first_party_sets/first_party_sets_loader.h
index 1c49082d2fb462b0974ddf1bf46c4a254582b3c4..151ae13e930b0dace6de02156077f491a61f8256 100644
--- a/content/browser/first_party_sets/first_party_sets_loader.h
+++ b/content/browser/first_party_sets/first_party_sets_loader.h
@@ -12,9 +12,11 @@
 #include "base/sequence_checker.h"
 #include "base/thread_annotations.h"
 #include "base/timer/elapsed_timer.h"
+#include "content/browser/first_party_sets/local_set_declaration.h"
 #include "content/common/content_export.h"
 #include "net/first_party_sets/global_first_party_sets.h"
 #include "net/first_party_sets/local_set_declaration.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace content {
 
@@ -37,7 +39,7 @@ class CONTENT_EXPORT FirstPartySetsLoader {
 
   // Stores the First-Party Set that was provided via the `kUseFirstPartySet`
   // flag/switch. Only the first call has any effect.
-  void SetManuallySpecifiedSet(const net::LocalSetDeclaration& local_set);
+  void SetManuallySpecifiedSet(const LocalSetDeclaration& local_set);
 
   // Asynchronously parses and stores the sets from `sets_file`, and merges with
   // any previously-loaded sets as needed. In case of invalid input, the set of
@@ -66,7 +68,7 @@ class CONTENT_EXPORT FirstPartySetsLoader {
 
   // Holds the set that was provided on the command line (if any). This is
   // nullopt until `SetManuallySpecifiedSet` is called.
-  std::optional<net::LocalSetDeclaration> manually_specified_set_
+  absl::optional<LocalSetDeclaration> manually_specified_set_
       GUARDED_BY_CONTEXT(sequence_checker_);
 
   enum Progress {
diff --git a/content/browser/first_party_sets/local_set_declaration.cc b/content/browser/first_party_sets/local_set_declaration.cc
new file mode 100644
index 0000000000000000000000000000000000000000..ec77f974a1ffad3fcb8ceb027eeb2c009dfed79c
--- /dev/null
+++ b/content/browser/first_party_sets/local_set_declaration.cc
@@ -0,0 +1,89 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/first_party_sets/local_set_declaration.h"
+
+#include <sstream>
+#include <string>
+
+#include "base/logging.h"
+#include "base/ranges/algorithm.h"
+#include "content/browser/first_party_sets/first_party_set_parser.h"
+#include "net/base/schemeful_site.h"
+#include "net/first_party_sets/first_party_set_entry.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+
+namespace content {
+
+namespace {
+
+absl::optional<FirstPartySetParser::SingleSet> CanonicalizeSet(
+    const std::string& use_first_party_set_flag_value) {
+  std::istringstream stream(use_first_party_set_flag_value);
+
+  FirstPartySetParser::SetsAndAliases parsed =
+      FirstPartySetParser::ParseSetsFromStream(stream, /*emit_errors=*/true,
+                                               /*emit_metrics*/ false);
+
+  FirstPartySetParser::SetsMap entries = std::move(parsed.first);
+  FirstPartySetParser::Aliases aliases = std::move(parsed.second);
+
+  if (entries.empty()) {
+    return absl::nullopt;
+  }
+
+  const net::SchemefulSite primary = entries.begin()->second.primary();
+
+  if (base::ranges::any_of(
+          entries,
+          [&primary](const FirstPartySetParser::SetsMap::value_type& pair) {
+            return pair.second.primary() != primary;
+          })) {
+    // More than one set was provided. That is (currently) unsupported.
+    LOG(ERROR) << "Ignoring use-related-website-set switch due to multiple set "
+                  "declarations.";
+    return absl::nullopt;
+  }
+
+  for (const auto& [alias, canonical] : aliases) {
+    auto it = entries.find(canonical);
+    CHECK(it != entries.end());
+    bool inserted = entries.emplace(alias, it->second).second;
+    CHECK(inserted);
+  }
+
+  return absl::make_optional(std::move(entries));
+}
+
+}  // namespace
+
+LocalSetDeclaration::LocalSetDeclaration()
+    : LocalSetDeclaration(absl::nullopt) {}
+
+LocalSetDeclaration::LocalSetDeclaration(
+    const std::string& use_first_party_set_flag_value)
+    : LocalSetDeclaration(CanonicalizeSet(use_first_party_set_flag_value)) {}
+
+LocalSetDeclaration::LocalSetDeclaration(
+    absl::optional<FirstPartySetParser::SingleSet> parsed_set)
+    : parsed_set_(std::move(parsed_set)) {}
+
+LocalSetDeclaration::~LocalSetDeclaration() = default;
+
+LocalSetDeclaration::LocalSetDeclaration(const LocalSetDeclaration&) = default;
+LocalSetDeclaration& LocalSetDeclaration::operator=(
+    const LocalSetDeclaration&) = default;
+
+LocalSetDeclaration::LocalSetDeclaration(LocalSetDeclaration&&) = default;
+LocalSetDeclaration& LocalSetDeclaration::operator=(LocalSetDeclaration&&) =
+    default;
+
+const FirstPartySetParser::SingleSet& LocalSetDeclaration::GetSet() const {
+  CHECK(!empty());
+  const FirstPartySetParser::SingleSet& set = parsed_set_.value();
+  CHECK(!set.empty());
+  return set;
+}
+
+}  // namespace content
diff --git a/content/browser/first_party_sets/local_set_declaration.h b/content/browser/first_party_sets/local_set_declaration.h
new file mode 100644
index 0000000000000000000000000000000000000000..7d1e3e6dd810a81d2abdd9a5cbfaa8faef277f77
--- /dev/null
+++ b/content/browser/first_party_sets/local_set_declaration.h
@@ -0,0 +1,48 @@
+// Copyright 2022 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_FIRST_PARTY_SETS_LOCAL_SET_DECLARATION_H_
+#define CONTENT_BROWSER_FIRST_PARTY_SETS_LOCAL_SET_DECLARATION_H_
+
+#include <string>
+
+#include "content/browser/first_party_sets/first_party_set_parser.h"
+#include "content/common/content_export.h"
+
+namespace content {
+
+class CONTENT_EXPORT LocalSetDeclaration {
+ public:
+  LocalSetDeclaration();
+
+  explicit LocalSetDeclaration(
+      const std::string& use_first_party_set_flag_value);
+
+  ~LocalSetDeclaration();
+
+  LocalSetDeclaration(const LocalSetDeclaration&);
+  LocalSetDeclaration& operator=(const LocalSetDeclaration&);
+  LocalSetDeclaration(LocalSetDeclaration&&);
+  LocalSetDeclaration& operator=(LocalSetDeclaration&&);
+
+  bool empty() const { return !parsed_set_.has_value(); }
+
+  size_t size() const { return empty() ? 0 : GetSet().size(); }
+
+  // Gets the set entries. Must not be called if `empty()` returns true.
+  const FirstPartySetParser::SingleSet& GetSet() const;
+
+ private:
+  explicit LocalSetDeclaration(
+      absl::optional<FirstPartySetParser::SingleSet> parsed_set);
+
+  // Stores the result of parsing the inputs. Specifically, this may be empty if
+  // no set was locally defined; otherwise, it holds the collection of
+  // FirstPartySetEntries and any ccTLD aliases.
+  absl::optional<FirstPartySetParser::SingleSet> parsed_set_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_FIRST_PARTY_SETS_LOCAL_SET_DECLARATION_H_
diff --git a/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.cc b/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.cc
index d9325e80b26c9aba49c5d71fc49daeac14933685..e3b2f0428a1ff0234326cc30bcd5a724c7c231be 100644
--- a/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.cc
+++ b/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.cc
@@ -44,7 +44,7 @@ ScopedMockFirstPartySetsHandler::FindEntry(
 
 void ScopedMockFirstPartySetsHandler::Init(
     const base::FilePath& user_data_dir,
-    const net::LocalSetDeclaration& local_set) {}
+    const LocalSetDeclaration& local_set) {}
 
 [[nodiscard]] std::optional<net::GlobalFirstPartySets>
 ScopedMockFirstPartySetsHandler::GetSets(
diff --git a/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.h b/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.h
index 5df5104bf47270a038de4e188ac2592adccf590f..de44481760169c409369d38ff48edc84d194b34f 100644
--- a/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.h
+++ b/content/browser/first_party_sets/test/scoped_mock_first_party_sets_handler.h
@@ -7,6 +7,7 @@
 
 #include <optional>
 #include <string>
+#include <utility>
 
 #include "base/functional/callback.h"
 #include "base/memory/raw_ptr.h"
@@ -67,8 +68,8 @@ class ScopedMockFirstPartySetsHandler
                              const net::FirstPartySetEntry&)> f) const override;
   // FirstPartySetsHandlerImpl:
   void Init(const base::FilePath& user_data_dir,
-            const net::LocalSetDeclaration& local_set) override;
-  [[nodiscard]] std::optional<net::GlobalFirstPartySets> GetSets(
+            const LocalSetDeclaration& local_set) override;
+  [[nodiscard]] absl::optional<net::GlobalFirstPartySets> GetSets(
       base::OnceCallback<void(net::GlobalFirstPartySets)> callback) override;
 
   // Helper functions for tests to set up context.
diff --git a/net/cookies/canonical_cookie.cc b/net/cookies/canonical_cookie.cc
index 02636104eae6d2223d637a11a89f92fcaf1497cc..7aab1829aef85dcae8890193400ef401f69a5e44 100644
--- a/net/cookies/canonical_cookie.cc
+++ b/net/cookies/canonical_cookie.cc
@@ -1252,6 +1252,7 @@ CookieAccessResult CanonicalCookie::IncludeForRequestURL(
         CookieInclusionStatus::EXCLUDE_SAMESITE_NONE_INSECURE);
   }
 
+  // Only apply SameSite-related warnings if SameParty is not in effect.
   ApplySameSiteCookieWarningToStatus(SameSite(), effective_same_site,
                                      IsSecure(),
                                      options.same_site_cookie_context(),
@@ -1425,6 +1426,7 @@ CookieAccessResult CanonicalCookie::IsSetPermittedInContext(
       break;
   }
 
+  // Only apply SameSite-related warnings if SameParty is not in effect.
   ApplySameSiteCookieWarningToStatus(
       SameSite(), access_result.effective_same_site, IsSecure(),
       options.same_site_cookie_context(), &access_result.status,
diff --git a/net/cookies/canonical_cookie.h b/net/cookies/canonical_cookie.h
index 599b17b834e6816f05f029014e2e53cb067a318d..d6c0ac2537c1029f097b2d01693672751fddb71d 100644
--- a/net/cookies/canonical_cookie.h
+++ b/net/cookies/canonical_cookie.h
@@ -240,6 +240,7 @@ class NET_EXPORT CanonicalCookie {
   bool IsHttpOnly() const { return httponly_; }
   CookieSameSite SameSite() const { return same_site_; }
   CookiePriority Priority() const { return priority_; }
+  bool IsSameParty() const { return false; }
   bool IsPartitioned() const { return partition_key_.has_value(); }
   const absl::optional<CookiePartitionKey>& PartitionKey() const {
     return partition_key_;
diff --git a/net/cookies/cookie_inclusion_status.h b/net/cookies/cookie_inclusion_status.h
index 98d8012e544a537da8f0bd51a03bcda230178d78..840b0187c984a9e4bbe66e35e1fdb6e871d6a583 100644
--- a/net/cookies/cookie_inclusion_status.h
+++ b/net/cookies/cookie_inclusion_status.h
@@ -78,7 +78,8 @@ class NET_EXPORT CookieInclusionStatus {
     // Cookie was set with an invalid __Host- or __Secure- prefix.
     EXCLUDE_INVALID_PREFIX = 15,
     /// Cookie was set with an invalid Partitioned attribute, which is only
-    // valid if the cookie has a __Host- prefix.
+    // valid if the cookie has a __Host- prefix and does not have the SameParty
+    // attribute.
     EXCLUDE_INVALID_PARTITIONED = 16,
     // Cookie exceeded the name/value pair size limit.
     EXCLUDE_NAME_VALUE_PAIR_EXCEEDS_MAX_SIZE = 17,
@@ -378,7 +379,9 @@ class NET_EXPORT CookieInclusionStatus {
 
   // Returns true if the cookie was excluded because of user preferences.
   // HasOnlyExclusionReason(EXCLUDE_USER_PREFERENCES) will not return true for
-  // third-party cookies blocked in sites in the same First-Party Set. See
+  // third-party cookies blocked in sites in the same First-Party Set (note:
+  // this is not the same as the cookie being blocked in a same-party context,
+  // which takes the entire ancestor chain into account). See
   // https://crbug.com/1366868.
   bool ExcludedByUserPreferences() const;
 
diff --git a/net/cookies/cookie_monster_netlog_params.cc b/net/cookies/cookie_monster_netlog_params.cc
index 667920356812c6675ae2ce4f83ab0ecf85df0abe..7f766060610af6056480ec241b6a4f03d4fb0be2 100644
--- a/net/cookies/cookie_monster_netlog_params.cc
+++ b/net/cookies/cookie_monster_netlog_params.cc
@@ -33,6 +33,7 @@ base::Value::Dict NetLogCookieMonsterCookieAdded(
   dict.Set("same_site", CookieSameSiteToString(cookie->SameSite()));
   dict.Set("is_persistent", cookie->IsPersistent());
   dict.Set("sync_requested", sync_requested);
+  dict.Set("same_party", cookie->IsSameParty());
   return dict;
 }
 
diff --git a/net/cookies/cookie_options.h b/net/cookies/cookie_options.h
index b240265067e9ee72f8f15092a5fb63aed9c0d563..183c1f61c1fbe94c8c85dd4f9a27695a04aad816 100644
--- a/net/cookies/cookie_options.h
+++ b/net/cookies/cookie_options.h
@@ -228,12 +228,14 @@ class NET_EXPORT CookieOptions {
   // * Excludes SameSite cookies
   // * Updates last-accessed time.
   // * Does not report excluded cookies in APIs that can do so.
+  // * Excludes SameParty cookies.
   //
   // These settings can be altered by calling:
   //
   // * |set_{include,exclude}_httponly()|
   // * |set_same_site_cookie_context()|
   // * |set_do_not_update_access_time()|
+  // * |set_same_party_cookie_context_type()|
   CookieOptions();
   CookieOptions(const CookieOptions& other);
   CookieOptions(CookieOptions&& other);
diff --git a/net/extras/sqlite/sqlite_persistent_cookie_store.cc b/net/extras/sqlite/sqlite_persistent_cookie_store.cc
index 0adc6857266535320dedbeee8881f50b14d213f1..41aa215e6226103ddf6231484113a4037b340c4e 100644
--- a/net/extras/sqlite/sqlite_persistent_cookie_store.cc
+++ b/net/extras/sqlite/sqlite_persistent_cookie_store.cc
@@ -228,8 +228,8 @@ namespace {
 // Version 3 updated the database to include the last access time, so we can
 // expire them in decreasing order of use when we've reached the maximum
 // number of cookies.
-const int kCurrentVersionNumber = 21;
-const int kCompatibleVersionNumber = 21;
+const int kCurrentVersionNumber = 20;
+const int kCompatibleVersionNumber = 20;
 
 }  // namespace
 
@@ -796,7 +796,7 @@ bool SQLitePersistentCookieStore::Backend::CreateDatabaseSchema() {
   if (db()->DoesTableExist("cookies"))
     return true;
 
-  return CreateV21Schema(db());
+  return CreateV20Schema(db());
 }
 
 bool SQLitePersistentCookieStore::Backend::DoInitializeDatabase() {
@@ -870,14 +870,14 @@ bool SQLitePersistentCookieStore::Backend::LoadCookiesForDomains(
         "SELECT creation_utc, host_key, top_frame_site_key, name, value, path, "
         "expires_utc, is_secure, is_httponly, last_access_utc, has_expires, "
         "is_persistent, priority, encrypted_value, samesite, source_scheme, "
-        "source_port, last_update_utc FROM cookies WHERE host_key = ?"));
+        "source_port, is_same_party, last_update_utc FROM cookies WHERE host_key = ?"));
   } else {
     smt.Assign(db()->GetCachedStatement(
         SQL_FROM_HERE,
         "SELECT creation_utc, host_key, top_frame_site_key, name, value, path, "
         "expires_utc, is_secure, is_httponly, last_access_utc, has_expires, "
         "is_persistent, priority, encrypted_value, samesite, source_scheme, "
-        "source_port, last_update_utc FROM cookies WHERE "
+        "source_port, is_same_party, last_update_utc FROM cookies WHERE "
         "host_key = ? AND "
         "is_persistent = 1"));
   }
@@ -984,7 +984,7 @@ bool SQLitePersistentCookieStore::Backend::MakeCookiesFromSQLStatement(
         statement.ColumnTime(0),    // creation_utc
         statement.ColumnTime(6),    // expires_utc
         statement.ColumnTime(9),    // last_access_utc
-        statement.ColumnTime(17),   // last_update_utc
+        statement.ColumnTime(18),   // last_update_utc
         statement.ColumnBool(7),    // secure
         statement.ColumnBool(8),    // http_only
         DBCookieSameSiteToCookieSameSite(static_cast<DBCookieSameSite>(
@@ -1225,55 +1225,6 @@ SQLitePersistentCookieStore::Backend::DoMigrateDatabaseSchema() {
     }
   }
 
-  if (cur_version == 20) {
-    SCOPED_UMA_HISTOGRAM_TIMER("Cookie.TimeDatabaseMigrationToV21");
-
-    sql::Transaction transaction(db());
-    if (!transaction.Begin()) {
-      return absl::nullopt;
-    }
-
-    if (!db()->Execute("DROP TABLE IF EXISTS cookies_old")) {
-      return absl::nullopt;
-    }
-    if (!db()->Execute("ALTER TABLE cookies RENAME TO cookies_old")) {
-      return absl::nullopt;
-    }
-    if (!db()->Execute("DROP INDEX IF EXISTS cookies_unique_index")) {
-      return absl::nullopt;
-    }
-
-    if (!CreateV21Schema(db())) {
-      return absl::nullopt;
-    }
-
-    static constexpr char insert_cookies_sql[] =
-        "INSERT OR REPLACE INTO cookies "
-        "(creation_utc, host_key, top_frame_site_key, name, value, "
-        "encrypted_value, path, expires_utc, is_secure, is_httponly, "
-        "last_access_utc, has_expires, is_persistent, priority, samesite, "
-        "source_scheme, source_port, last_update_utc) "
-        "SELECT creation_utc, host_key, top_frame_site_key, name, value,"
-        "       encrypted_value, path, expires_utc, is_secure, is_httponly,"
-        "       last_access_utc, has_expires, is_persistent, priority, "
-        "       samesite, source_scheme, source_port, last_update_utc "
-        "FROM cookies_old ORDER BY creation_utc ASC";
-    if (!db()->Execute(insert_cookies_sql)) {
-      return absl::nullopt;
-    }
-    if (!db()->Execute("DROP TABLE cookies_old")) {
-      return absl::nullopt;
-    }
-
-    ++cur_version;
-    if (!meta_table()->SetVersionNumber(cur_version) ||
-        !meta_table()->SetCompatibleVersionNumber(
-            std::min(cur_version, kCompatibleVersionNumber)) ||
-        !transaction.Commit()) {
-      return absl::nullopt;
-    }
-  }
-
   // Put future migration cases here.
 
   return absl::make_optional(cur_version);
@@ -1375,7 +1326,7 @@ void SQLitePersistentCookieStore::Backend::DoCommit() {
       "INSERT INTO cookies (creation_utc, host_key, top_frame_site_key, name, "
       "value, encrypted_value, path, expires_utc, is_secure, is_httponly, "
       "last_access_utc, has_expires, is_persistent, priority, samesite, "
-      "source_scheme, source_port, last_update_utc) "
+      "source_scheme, source_port, is_same_party, last_update_utc) "
       "VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)"));
   if (!add_statement.is_valid())
     return;
@@ -1444,7 +1395,8 @@ void SQLitePersistentCookieStore::Backend::DoCommit() {
               14, CookieSameSiteToDBCookieSameSite(po->cc().SameSite()));
           add_statement.BindInt(15, static_cast<int>(po->cc().SourceScheme()));
           add_statement.BindInt(16, po->cc().SourcePort());
-          add_statement.BindTime(17, po->cc().LastUpdateDate());
+          add_statement.BindBool(17, po->cc().IsSameParty());
+          add_statement.BindTime(18, po->cc().LastUpdateDate());
           if (!add_statement.Run()) {
             DLOG(WARNING) << "Could not add a cookie to the DB.";
             RecordCookieCommitProblem(COOKIE_COMMIT_PROBLEM_ADD);
diff --git a/net/first_party_sets/global_first_party_sets.cc b/net/first_party_sets/global_first_party_sets.cc
index c916b0f4e106afdef92b3cd4d95cff3edf4d5594..10106c045eb8202d104288d687dd83194b5ba64b 100644
--- a/net/first_party_sets/global_first_party_sets.cc
+++ b/net/first_party_sets/global_first_party_sets.cc
@@ -19,7 +19,6 @@
 #include "net/first_party_sets/first_party_set_entry_override.h"
 #include "net/first_party_sets/first_party_set_metadata.h"
 #include "net/first_party_sets/first_party_sets_context_config.h"
-#include "net/first_party_sets/local_set_declaration.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace net {
@@ -76,29 +75,25 @@ GlobalFirstPartySets::GlobalFirstPartySets(
           public_sets_version.IsValid()
               ? std::move(aliases)
               : base::flat_map<SchemefulSite, SchemefulSite>(),
-          FirstPartySetsContextConfig(),
-          base::flat_map<SchemefulSite, SchemefulSite>()) {}
+          FirstPartySetsContextConfig()) {}
 
 GlobalFirstPartySets::GlobalFirstPartySets(
     base::Version public_sets_version,
     base::flat_map<SchemefulSite, FirstPartySetEntry> entries,
     base::flat_map<SchemefulSite, SchemefulSite> aliases,
-    FirstPartySetsContextConfig manual_config,
-    base::flat_map<SchemefulSite, SchemefulSite> manual_aliases)
+    FirstPartySetsContextConfig manual_config)
     : public_sets_version_(std::move(public_sets_version)),
       entries_(std::move(entries)),
       aliases_(std::move(aliases)),
-      manual_config_(std::move(manual_config)),
-      manual_aliases_(std::move(manual_aliases)) {
-  if (!public_sets_version_.IsValid()) {
+      manual_config_(std::move(manual_config)) {
+  if (public_sets_version_.IsValid()) {
+    CHECK(base::ranges::all_of(aliases_, [&](const auto& pair) {
+      return entries_.contains(pair.second);
+    }));
+  } else {
     CHECK(entries_.empty());
     CHECK(aliases_.empty());
   }
-
-  CHECK(base::ranges::all_of(aliases_, [&](const auto& pair) {
-    return entries_.contains(pair.second);
-  }));
-  CHECK(!ContainsSingleton());
 }
 
 GlobalFirstPartySets::GlobalFirstPartySets(GlobalFirstPartySets&&) = default;
@@ -107,15 +102,18 @@ GlobalFirstPartySets& GlobalFirstPartySets::operator=(GlobalFirstPartySets&&) =
 
 GlobalFirstPartySets::~GlobalFirstPartySets() = default;
 
-bool GlobalFirstPartySets::operator==(const GlobalFirstPartySets& other) const =
-    default;
+bool GlobalFirstPartySets::operator==(const GlobalFirstPartySets& other) const {
+  return std::tie(public_sets_version_, entries_, aliases_, manual_config_) ==
+         std::tie(other.public_sets_version_, other.entries_, other.aliases_,
+                  other.manual_config_);
+}
 
 bool GlobalFirstPartySets::operator!=(const GlobalFirstPartySets& other) const =
     default;
 
 GlobalFirstPartySets GlobalFirstPartySets::Clone() const {
   return GlobalFirstPartySets(public_sets_version_, entries_, aliases_,
-                              manual_config_.Clone(), manual_aliases_);
+                              manual_config_.Clone());
 }
 
 absl::optional<FirstPartySetEntry> GlobalFirstPartySets::FindEntry(
@@ -184,31 +182,12 @@ FirstPartySetMetadata GlobalFirstPartySets::ComputeMetadata(
 }
 
 void GlobalFirstPartySets::ApplyManuallySpecifiedSet(
-    const LocalSetDeclaration& local_set_declaration) {
+    const base::flat_map<SchemefulSite, FirstPartySetEntry>& manual_entries) {
   CHECK(manual_config_.empty());
-  CHECK(manual_aliases_.empty());
-  if (local_set_declaration.empty()) {
-    // Nothing to do.
-    return;
-  }
-
-  base::flat_map<SchemefulSite, SchemefulSite> manual_aliases =
-      local_set_declaration.aliases();
-
-  base::flat_map<SchemefulSite, FirstPartySetEntry> manual_entries =
-      local_set_declaration.entries();
-  for (const auto& [alias, canonical] : manual_aliases) {
-    manual_entries.emplace(alias, manual_entries.find(canonical)->second);
-  }
-
   // We handle the manually-specified set the same way as we handle
   // replacement enterprise policy sets.
-  manual_config_ = ComputeConfig(SetsMutation(
-      /*replacement_sets=*/{manual_entries},
-      /*addition_sets=*/{}));
-  manual_aliases_ = std::move(manual_aliases);
-
-  CHECK(!ContainsSingleton());
+  manual_config_ = ComputeConfig(
+      /*replacement_sets=*/{manual_entries}, /*addition_sets=*/{});
 }
 
 void GlobalFirstPartySets::UnsafeSetManualConfig(
@@ -218,9 +197,8 @@ void GlobalFirstPartySets::UnsafeSetManualConfig(
 }
 
 FirstPartySetsContextConfig GlobalFirstPartySets::ComputeConfig(
-    const SetsMutation& mutation) const {
-  const std::vector<SingleSet>& replacement_sets = mutation.replacements();
-  const std::vector<SingleSet>& addition_sets = mutation.additions();
+    const std::vector<SingleSet>& replacement_sets,
+    const std::vector<SingleSet>& addition_sets) const {
   if (base::ranges::all_of(replacement_sets,
                            [](const SingleSet& set) { return set.empty(); }) &&
       base::ranges::all_of(addition_sets,
@@ -334,15 +312,14 @@ FirstPartySetsContextConfig GlobalFirstPartySets::ComputeConfig(
     }
   }
 
-  // For every pre-existing alias that would now refer to a site in the overlay,
-  // which is not already contained in the overlay, we explicitly ignore that
-  // alias.
-  ForEachAlias([&](const SchemefulSite& alias, const SchemefulSite& canonical) {
-    if (base::Contains(site_to_entry, canonical, ProjectKey) &&
+  // For every public alias that would now refer to a site in the overlay, which
+  // is not already contained in the overlay, we explicitly ignore that alias.
+  for (const auto& [alias, site] : aliases_) {
+    if (base::Contains(site_to_entry, site, ProjectKey) &&
         !base::Contains(site_to_entry, alias, ProjectKey)) {
       site_to_entry.emplace_back(alias, FirstPartySetEntryOverride());
     }
-  });
+  }
 
   return FirstPartySetsContextConfig(std::move(site_to_entry));
 }
@@ -466,42 +443,6 @@ bool GlobalFirstPartySets::ForEachEffectiveSetEntry(
   });
 }
 
-void GlobalFirstPartySets::ForEachAlias(
-    base::FunctionRef<void(const SchemefulSite&, const SchemefulSite&)> f)
-    const {
-  for (const auto& [alias, site] : manual_aliases_) {
-    f(alias, site);
-  }
-  for (const auto& [alias, site] : aliases_) {
-    if (manual_config_.Contains(alias)) {
-      continue;
-    }
-    f(alias, site);
-  }
-}
-
-bool GlobalFirstPartySets::ContainsSingleton() const {
-  std::set<SchemefulSite> possible_singletons;
-  std::set<SchemefulSite> not_singletons;
-
-  ForEachEffectiveSetEntry(
-      nullptr,
-      [&](const SchemefulSite& site, const FirstPartySetEntry& entry) -> bool {
-        if (!not_singletons.contains(entry.primary())) {
-          if (site == entry.primary()) {
-            possible_singletons.insert(entry.primary());
-          } else {
-            not_singletons.insert(entry.primary());
-            possible_singletons.erase(entry.primary());
-          }
-        }
-
-        return true;
-      });
-
-  return !possible_singletons.empty();
-}
-
 std::ostream& operator<<(std::ostream& os, const GlobalFirstPartySets& sets) {
   os << "{entries = {";
   for (const auto& [site, entry] : sets.entries_) {
@@ -518,10 +459,6 @@ std::ostream& operator<<(std::ostream& os, const GlobalFirstPartySets& sets) {
         os << "{" << site.Serialize() << ": " << override << "},";
         return true;
       });
-  os << "}, manual_aliases = {";
-  for (const auto& [alias, canonical] : sets.manual_aliases_) {
-    os << "{" << alias.Serialize() << ": " << canonical.Serialize() << "}, ";
-  }
   os << "}}";
   return os;
 }
diff --git a/net/first_party_sets/global_first_party_sets.h b/net/first_party_sets/global_first_party_sets.h
index d87aaec1747738a29dc03cdfcb9266c48ef8b699..f4f4e99189e0f3b8accfa884e136a127d0128bab 100644
--- a/net/first_party_sets/global_first_party_sets.h
+++ b/net/first_party_sets/global_first_party_sets.h
@@ -5,6 +5,8 @@
 #ifndef NET_FIRST_PARTY_SETS_GLOBAL_FIRST_PARTY_SETS_H_
 #define NET_FIRST_PARTY_SETS_GLOBAL_FIRST_PARTY_SETS_H_
 
+#include <set>
+
 #include "base/containers/flat_map.h"
 #include "base/containers/flat_set.h"
 #include "base/functional/function_ref.h"
@@ -14,8 +16,6 @@
 #include "net/first_party_sets/first_party_set_entry.h"
 #include "net/first_party_sets/first_party_set_entry_override.h"
 #include "net/first_party_sets/first_party_sets_context_config.h"
-#include "net/first_party_sets/local_set_declaration.h"
-#include "net/first_party_sets/sets_mutation.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
 namespace mojo {
@@ -55,8 +55,15 @@ class NET_EXPORT GlobalFirstPartySets {
   GlobalFirstPartySets Clone() const;
 
   // Returns a FirstPartySetsContextConfig that respects the overrides given by
-  // `mutation`, relative to this instance's state.
-  FirstPartySetsContextConfig ComputeConfig(const SetsMutation& mutation) const;
+  // `replacement_sets` and `addition_sets`, relative to this instance's state.
+  //
+  // Preconditions: sets defined by `replacement_sets` and
+  // `addition_sets` must be disjoint.
+  FirstPartySetsContextConfig ComputeConfig(
+      const std::vector<base::flat_map<SchemefulSite, FirstPartySetEntry>>&
+          replacement_sets,
+      const std::vector<base::flat_map<SchemefulSite, FirstPartySetEntry>>&
+          addition_sets) const;
 
   // Returns the entry corresponding to the given `site`, if one exists.
   // Respects any customization/overlay specified by `config`. This is
@@ -79,9 +86,10 @@ class NET_EXPORT GlobalFirstPartySets {
       const FirstPartySetsContextConfig& fps_context_config) const;
 
   // Modifies this instance such that it will respect the given
-  // manually-specified set.
+  // manually-specified set. `manual_entries` should contain entries for aliases
+  // as well as "canonical" sites.
   void ApplyManuallySpecifiedSet(
-      const LocalSetDeclaration& local_set_declaration);
+      const base::flat_map<SchemefulSite, FirstPartySetEntry>& manual_entries);
 
   // Directly sets this instance's manual config. This is unsafe, because it
   // assumes that the config was computed by this instance (or one with
@@ -141,8 +149,7 @@ class NET_EXPORT GlobalFirstPartySets {
       base::Version public_sets_version,
       base::flat_map<SchemefulSite, FirstPartySetEntry> entries,
       base::flat_map<SchemefulSite, SchemefulSite> aliases,
-      FirstPartySetsContextConfig manual_config,
-      base::flat_map<SchemefulSite, SchemefulSite> manual_aliases);
+      FirstPartySetsContextConfig manual_config);
 
   // Same as the public version of FindEntry, but is allowed to omit the
   // `config` argument (i.e. pass nullptr instead of a reference).
@@ -166,16 +173,6 @@ class NET_EXPORT GlobalFirstPartySets {
       base::FunctionRef<bool(const SchemefulSite&, const FirstPartySetEntry&)>
           f) const;
 
-  // Iterates over the mappings in `manual_aliases_` and `aliases_` (skipping
-  // entries of `aliases_` that are shadowed), invoking `f` for each `alias,
-  // canonical` pair.
-  void ForEachAlias(base::FunctionRef<void(const SchemefulSite&,
-                                           const SchemefulSite&)> f) const;
-
-  // Returns true iff this instance contains a singleton set (a set with only
-  // one site).
-  bool ContainsSingleton() const;
-
   // The version associated with the component_updater-provided public sets.
   // This may be invalid if the "First-Party Sets" component has not been
   // installed yet, or has been corrupted. Entries and aliases from invalid
@@ -193,10 +190,6 @@ class NET_EXPORT GlobalFirstPartySets {
   // Stores the customizations induced by the manually-specified set. May be
   // empty if no switch was provided.
   FirstPartySetsContextConfig manual_config_;
-
-  // Stores the aliases contained in the manually-specified set. (Note that the
-  // aliases are *also* stored in `manual_config_`.)
-  base::flat_map<SchemefulSite, SchemefulSite> manual_aliases_;
 };
 
 NET_EXPORT std::ostream& operator<<(std::ostream& os,
diff --git a/net/first_party_sets/local_set_declaration.cc b/net/first_party_sets/local_set_declaration.cc
index e86933593a7d471f4100e44dc18d74a5ef4480a0..c37b932c20d204ea074f0cdf5ad1cfabc94a04b3 100644
--- a/net/first_party_sets/local_set_declaration.cc
+++ b/net/first_party_sets/local_set_declaration.cc
@@ -13,16 +13,11 @@ namespace net {
 LocalSetDeclaration::LocalSetDeclaration() = default;
 
 LocalSetDeclaration::LocalSetDeclaration(
-    base::flat_map<SchemefulSite, FirstPartySetEntry> set_entries,
-    base::flat_map<SchemefulSite, SchemefulSite> aliases)
-    : entries_(std::move(set_entries)), aliases_(std::move(aliases)) {
-  // Every alias must map to some canonical site in `entries_`.
-  CHECK(base::ranges::all_of(
-      aliases_, [&](const auto& p) { return entries_.contains(p.second); }));
-
+    base::flat_map<SchemefulSite, FirstPartySetEntry> set_entries)
+    : entries_(std::move(set_entries)) {
   if (!entries_.empty()) {
     // Must not be a singleton set (i.e. must have more than one entry).
-    CHECK_GT(entries_.size() + aliases_.size(), 1u);
+    CHECK_GT(entries_.size(), 1u);
 
     // All provided entries must have the same primary site. I.e., there must
     // only be one set.
diff --git a/net/first_party_sets/local_set_declaration.h b/net/first_party_sets/local_set_declaration.h
index 32814cf5157ba05e91bc87afa466272d24953c8e..6d6ad781ec088112dfe4e537a3587b206cd2b85d 100644
--- a/net/first_party_sets/local_set_declaration.h
+++ b/net/first_party_sets/local_set_declaration.h
@@ -30,8 +30,7 @@ class NET_EXPORT LocalSetDeclaration {
   // the same set (i.e. they must have the same primary site). The set must not
   // be a singleton (i.e. must have more than one entry, or must be empty).
   explicit LocalSetDeclaration(
-      base::flat_map<SchemefulSite, FirstPartySetEntry> set_entries,
-      base::flat_map<SchemefulSite, SchemefulSite> aliases);
+      base::flat_map<SchemefulSite, FirstPartySetEntry> set_entries);
 
   ~LocalSetDeclaration();
 
@@ -48,17 +47,10 @@ class NET_EXPORT LocalSetDeclaration {
     return entries_;
   }
 
-  const base::flat_map<SchemefulSite, SchemefulSite>& aliases() const {
-    return aliases_;
-  }
-
  private:
-  // Stores the set of entries, without ccTLD aliases. This may be empty if no
-  // set was locally defined.
+  // Stores the set of entries and ccTLD aliases. This may be empty if no set
+  // was locally defined.
   base::flat_map<SchemefulSite, FirstPartySetEntry> entries_;
-
-  // Stores the ccTLD aliases. May be empty.
-  base::flat_map<SchemefulSite, SchemefulSite> aliases_;
 };
 
 }  // namespace net
diff --git a/services/network/public/cpp/first_party_sets_mojom_traits.cc b/services/network/public/cpp/first_party_sets_mojom_traits.cc
index b5d5d26e7d2362ba2a9d17be393cb70cb001b827..0c20fd9b054b6bdf989adde7d9c03f4f784215d9 100644
--- a/services/network/public/cpp/first_party_sets_mojom_traits.cc
+++ b/services/network/public/cpp/first_party_sets_mojom_traits.cc
@@ -127,29 +127,8 @@ bool StructTraits<network::mojom::GlobalFirstPartySetsDataView,
   if (!sets.ReadManualConfig(&manual_config))
     return false;
 
-  base::flat_map<net::SchemefulSite, net::SchemefulSite> manual_aliases;
-  if (!sets.ReadManualAliases(&manual_aliases)) {
-    return false;
-  }
-
-  // The manual_config must contain both the alias overrides and their
-  // corresponding canonical overrides, none of which may be deletions.
-  if (!base::ranges::all_of(manual_aliases, [&](const auto& pair) {
-        absl::optional<net::FirstPartySetEntryOverride> aliased_override =
-            manual_config.FindOverride(pair.first);
-        absl::optional<net::FirstPartySetEntryOverride> canonical_override =
-            manual_config.FindOverride(pair.second);
-        return aliased_override.has_value() &&
-               !aliased_override->IsDeletion() &&
-               canonical_override.has_value() &&
-               !canonical_override->IsDeletion();
-      })) {
-    return false;
-  }
-
-  *out_sets = net::GlobalFirstPartySets(
-      std::move(public_sets_version), std::move(entries), std::move(aliases),
-      std::move(manual_config), std::move(manual_aliases));
+  *out_sets = net::GlobalFirstPartySets(std::move(public_sets_version), entries,
+                                        aliases, std::move(manual_config));
 
   return true;
 }
diff --git a/services/network/public/cpp/first_party_sets_mojom_traits.h b/services/network/public/cpp/first_party_sets_mojom_traits.h
index 8a03b2f3216fdce84c868d71188b8a702b51ad61..b255f56ead022bb237296e7560c73f692a7d7ee3 100644
--- a/services/network/public/cpp/first_party_sets_mojom_traits.h
+++ b/services/network/public/cpp/first_party_sets_mojom_traits.h
@@ -103,11 +103,6 @@ struct COMPONENT_EXPORT(FIRST_PARTY_SETS_MOJOM_TRAITS)
     return sets.manual_config_;
   }
 
-  static const base::flat_map<net::SchemefulSite, net::SchemefulSite>&
-  manual_aliases(const net::GlobalFirstPartySets& sets) {
-    return sets.manual_aliases_;
-  }
-
   static bool Read(network::mojom::GlobalFirstPartySetsDataView sets,
                    net::GlobalFirstPartySets* out_sets);
 };
diff --git a/services/network/public/mojom/first_party_sets.mojom b/services/network/public/mojom/first_party_sets.mojom
index 875138dee43ec8739c35fbab27e27ca0fc502e69..0ea745cd2450c2d92002c3a0113295b0d4bbd40e 100644
--- a/services/network/public/mojom/first_party_sets.mojom
+++ b/services/network/public/mojom/first_party_sets.mojom
@@ -83,11 +83,7 @@ struct GlobalFirstPartySets {
   // The mapping from site alias to canonical site from public sets.
   map<SchemefulSite, SchemefulSite> aliases;
 
-  // The config induced by the manually-supplied set. This config contains all
-  // relevant ccTLD aliases.
+  // The config induced by the manually-supplied set.
   FirstPartySetsContextConfig manual_config;
-
-  // The aliases contained in the manually-supplied set.
-  map<SchemefulSite, SchemefulSite> manual_aliases;
 };
 
diff --git a/services/network/public/mojom/network_context.mojom b/services/network/public/mojom/network_context.mojom
index e6c2bb7599d1606725c982db98255a04ed456419..1de4e2666492196bb5dcd5a45632fe0928cc0a82 100644
--- a/services/network/public/mojom/network_context.mojom
+++ b/services/network/public/mojom/network_context.mojom
@@ -1013,7 +1013,7 @@ interface NetworkContext {
   // document's frame)), or a request origin when |role| is
   // RestrictedCookieManagerRole::NETWORK (a network request).
   //
-  // |isolation_info| contains info for SameSite cookie queries.
+  // |isolation_info| contains info for SameSite and SameParty cookie queries.
   // Must be fully populated.
   //
   // If |role| == SCRIPT, this interface can be safely handed out to a process
diff --git a/third_party/blink/public/devtools_protocol/browser_protocol.pdl b/third_party/blink/public/devtools_protocol/browser_protocol.pdl
index 5c830ad4623ccb59d71d3f842e45927140597a95..025d11f055ac609a3889050b08aa0881a55933f2 100644
--- a/third_party/blink/public/devtools_protocol/browser_protocol.pdl
+++ b/third_party/blink/public/devtools_protocol/browser_protocol.pdl
@@ -5858,7 +5858,7 @@ domain Network
       # Cookie Priority
       experimental CookiePriority priority
       # True if cookie is SameParty.
-      experimental deprecated boolean sameParty
+      experimental boolean sameParty
       # Cookie source scheme type.
       experimental CookieSourceScheme sourceScheme
       # Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
